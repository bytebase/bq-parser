// Code generated from BigQueryParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // BigQueryParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type BigQueryParser struct {
	*antlr.BaseParser
}

var BigQueryParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func bigqueryparserParserInit() {
	staticData := &BigQueryParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'''", "'\"'", "';'", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "'.'", "'`'", "'('", "')'", "'['", "']'", "'='", "'<'", "'>'",
		"'<<'", "'>>'", "'<='", "'>='", "'!='", "'<>'", "'&'", "'|'", "'*'",
		"'/'", "'+'", "'-'", "','", "'~'", "'^'",
	}
	staticData.SymbolicNames = []string{
		"", "QUOTE", "DQOUTE", "SEMI", "ALL", "AND", "ANY", "ARRAY", "AS", "ASC",
		"ASSERT_ROWS_MODIFIED", "AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE",
		"CONTAINS", "CREATE", "CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE",
		"DESC", "DISTINCT", "ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE",
		"EXISTS", "EXTRACT", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL",
		"GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN",
		"INNER", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT",
		"LIKE", "LIMIT", "LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "S_NULL",
		"NULLS", "OF", "OFFSET", "ON", "OR", "ORDER", "ORDINAL", "OUTER", "OVER",
		"PARTITION", "PRECEDING", "PROTO", "RANGE", "RECURSIVE", "REPLACE",
		"RESPECT", "RIGHT", "ROLLUP", "ROWS", "SAFE_OFFSET", "SAFE_ORDINAL",
		"SELECT", "SET", "SOME", "SSTRUCT", "SYSTEM", "TABLESAMPLE", "THEN",
		"TIME", "TO", "TREAT", "TRUE", "UNBOUNDED", "UNION", "UNNEST", "USING",
		"WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "INT", "FLOAT", "DIGITS",
		"WS", "CMT", "M_CMT", "QUOTED_STRING", "TRIPLE_QUOTED_STRING", "RAW_STRING",
		"BYTE_STRING", "RAW_BYTE_STRING", "ID", "RB", "DOT", "BACKTICK", "LR_BRACKET",
		"RR_BRACKET", "LSB", "RSB", "EQ", "LT", "GT", "DOUBLE_LT", "DOUBLE_GT",
		"LE", "GE", "NE", "LTGT", "BIT_AND", "BIT_OR", "STAR", "DIVIDE", "PLUS",
		"MINUS", "COMMA", "TILDE", "CARET",
	}
	staticData.RuleNames = []string{
		"root", "stmtblock", "stmtmulti", "stmt", "query_statement", "query_expr",
		"select_statement", "from_statement", "from_item", "where_statement",
		"group_statement", "having_statement", "window_statement", "order_clause",
		"limit_clause", "unary_operator", "expr", "cast_expr", "column_expr",
		"except_statement", "replace_statement", "join_type", "on_clause", "set_op",
		"using_clause", "field_path", "sstruct", "array_expr", "array_path",
		"bool_expression", "window_name", "window_definition", "count", "skip_rows",
		"with_statement", "name", "alias_name", "array_name", "column_name",
		"cte_name", "dataset_name", "datatype_name", "function_name", "join_name",
		"member_name", "project_name", "struct_name", "table_name", "table_expr",
		"number", "integer_type", "float_type", "string", "quoted_string", "triple_quoted_string",
		"raw_string", "byte_string", "raw_byte_string", "special_string", "keyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 142, 784, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 3,
		2, 128, 8, 2, 5, 2, 130, 8, 2, 10, 2, 12, 2, 133, 9, 2, 1, 3, 1, 3, 1,
		4, 3, 4, 138, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 3, 5, 145, 8, 5, 1, 5,
		3, 5, 148, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 154, 8, 5, 1, 5, 3, 5, 157,
		8, 5, 3, 5, 159, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 165, 8, 5, 1, 5, 3,
		5, 168, 8, 5, 5, 5, 170, 8, 5, 10, 5, 12, 5, 173, 9, 5, 1, 6, 1, 6, 3,
		6, 177, 8, 6, 1, 6, 3, 6, 180, 8, 6, 1, 6, 3, 6, 183, 8, 6, 1, 6, 1, 6,
		3, 6, 187, 8, 6, 1, 6, 3, 6, 190, 8, 6, 1, 6, 1, 6, 3, 6, 194, 8, 6, 1,
		6, 3, 6, 197, 8, 6, 3, 6, 199, 8, 6, 1, 6, 1, 6, 3, 6, 203, 8, 6, 1, 6,
		1, 6, 3, 6, 207, 8, 6, 1, 6, 3, 6, 210, 8, 6, 1, 6, 1, 6, 3, 6, 214, 8,
		6, 1, 6, 3, 6, 217, 8, 6, 3, 6, 219, 8, 6, 5, 6, 221, 8, 6, 10, 6, 12,
		6, 224, 9, 6, 1, 6, 3, 6, 227, 8, 6, 1, 6, 3, 6, 230, 8, 6, 1, 6, 3, 6,
		233, 8, 6, 1, 6, 3, 6, 236, 8, 6, 1, 6, 3, 6, 239, 8, 6, 1, 7, 1, 7, 1,
		7, 1, 7, 5, 7, 245, 8, 7, 10, 7, 12, 7, 248, 9, 7, 1, 8, 1, 8, 1, 8, 3,
		8, 253, 8, 8, 1, 8, 3, 8, 256, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 264, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 270, 8, 8, 1, 8, 3, 8, 273,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 281, 8, 8, 1, 8, 3, 8,
		284, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 289, 8, 8, 1, 8, 3, 8, 292, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 299, 8, 8, 1, 8, 3, 8, 302, 8, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 307, 8, 8, 1, 8, 3, 8, 310, 8, 8, 1, 8, 1, 8, 3, 8, 314,
		8, 8, 1, 8, 3, 8, 317, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 322, 8, 8, 1, 8, 3,
		8, 325, 8, 8, 3, 8, 327, 8, 8, 1, 8, 1, 8, 3, 8, 331, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 337, 8, 8, 5, 8, 339, 8, 8, 10, 8, 12, 8, 342, 9, 8,
		1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 352, 8, 10,
		10, 10, 12, 10, 355, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 362,
		8, 10, 10, 10, 12, 10, 365, 9, 10, 1, 10, 1, 10, 3, 10, 369, 8, 10, 1,
		11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13,
		1, 13, 1, 13, 1, 13, 3, 13, 385, 8, 13, 1, 13, 1, 13, 1, 13, 3, 13, 390,
		8, 13, 5, 13, 392, 8, 13, 10, 13, 12, 13, 395, 9, 13, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 401, 8, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 3, 16, 421, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 426, 8, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 434, 8, 16, 10, 16, 12, 16,
		437, 9, 16, 1, 16, 3, 16, 440, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 453, 8, 16, 10, 16, 12,
		16, 456, 9, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 462, 8, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 491, 8, 16, 1, 16, 1, 16, 3, 16,
		495, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 502, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 514,
		8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 519, 8, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 5, 16, 526, 8, 16, 10, 16, 12, 16, 529, 9, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 539, 8, 16, 5, 16, 541,
		8, 16, 10, 16, 12, 16, 544, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 560,
		8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 565, 8, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 570, 8, 18, 1, 18, 3, 18, 573, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 5, 19, 580, 8, 19, 10, 19, 12, 19, 583, 9, 19, 1, 19, 1, 19, 1, 20,
		1, 20, 1, 20, 1, 20, 3, 20, 591, 8, 20, 1, 20, 3, 20, 594, 8, 20, 1, 20,
		1, 20, 1, 20, 3, 20, 599, 8, 20, 1, 20, 1, 20, 5, 20, 603, 8, 20, 10, 20,
		12, 20, 606, 9, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 614,
		8, 21, 1, 21, 1, 21, 3, 21, 618, 8, 21, 1, 21, 1, 21, 3, 21, 622, 8, 21,
		3, 21, 624, 8, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 631, 8, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 637, 8, 23, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 5, 24, 644, 8, 24, 10, 24, 12, 24, 647, 9, 24, 1, 24, 1, 24,
		1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 32,
		1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 5, 34, 688, 8, 34, 10, 34, 12, 34,
		691, 9, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 710,
		8, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1,
		40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45,
		1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 3, 48, 739, 8, 48, 1,
		48, 1, 48, 1, 48, 3, 48, 744, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		3, 48, 751, 8, 48, 1, 49, 1, 49, 3, 49, 755, 8, 49, 1, 50, 1, 50, 1, 51,
		1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 767, 8, 52, 1,
		53, 1, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58,
		1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 0, 3, 10, 16, 32, 60, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 0, 8, 2, 0, 4, 4, 25, 25, 2, 0, 9, 9, 24, 24, 3, 0, 63,
		63, 139, 139, 141, 141, 3, 0, 67, 67, 71, 71, 84, 85, 1, 0, 136, 137, 1,
		0, 138, 139, 1, 0, 128, 129, 1, 0, 4, 105, 863, 0, 120, 1, 0, 0, 0, 2,
		123, 1, 0, 0, 0, 4, 131, 1, 0, 0, 0, 6, 134, 1, 0, 0, 0, 8, 137, 1, 0,
		0, 0, 10, 158, 1, 0, 0, 0, 12, 174, 1, 0, 0, 0, 14, 240, 1, 0, 0, 0, 16,
		326, 1, 0, 0, 0, 18, 343, 1, 0, 0, 0, 20, 346, 1, 0, 0, 0, 22, 370, 1,
		0, 0, 0, 24, 373, 1, 0, 0, 0, 26, 380, 1, 0, 0, 0, 28, 396, 1, 0, 0, 0,
		30, 402, 1, 0, 0, 0, 32, 461, 1, 0, 0, 0, 34, 545, 1, 0, 0, 0, 36, 572,
		1, 0, 0, 0, 38, 574, 1, 0, 0, 0, 40, 586, 1, 0, 0, 0, 42, 623, 1, 0, 0,
		0, 44, 625, 1, 0, 0, 0, 46, 636, 1, 0, 0, 0, 48, 638, 1, 0, 0, 0, 50, 650,
		1, 0, 0, 0, 52, 652, 1, 0, 0, 0, 54, 657, 1, 0, 0, 0, 56, 662, 1, 0, 0,
		0, 58, 664, 1, 0, 0, 0, 60, 666, 1, 0, 0, 0, 62, 668, 1, 0, 0, 0, 64, 670,
		1, 0, 0, 0, 66, 672, 1, 0, 0, 0, 68, 674, 1, 0, 0, 0, 70, 709, 1, 0, 0,
		0, 72, 711, 1, 0, 0, 0, 74, 713, 1, 0, 0, 0, 76, 715, 1, 0, 0, 0, 78, 717,
		1, 0, 0, 0, 80, 719, 1, 0, 0, 0, 82, 721, 1, 0, 0, 0, 84, 723, 1, 0, 0,
		0, 86, 725, 1, 0, 0, 0, 88, 727, 1, 0, 0, 0, 90, 729, 1, 0, 0, 0, 92, 731,
		1, 0, 0, 0, 94, 733, 1, 0, 0, 0, 96, 750, 1, 0, 0, 0, 98, 754, 1, 0, 0,
		0, 100, 756, 1, 0, 0, 0, 102, 758, 1, 0, 0, 0, 104, 766, 1, 0, 0, 0, 106,
		768, 1, 0, 0, 0, 108, 770, 1, 0, 0, 0, 110, 772, 1, 0, 0, 0, 112, 774,
		1, 0, 0, 0, 114, 776, 1, 0, 0, 0, 116, 778, 1, 0, 0, 0, 118, 781, 1, 0,
		0, 0, 120, 121, 3, 2, 1, 0, 121, 122, 5, 0, 0, 1, 122, 1, 1, 0, 0, 0, 123,
		124, 3, 4, 2, 0, 124, 3, 1, 0, 0, 0, 125, 127, 3, 6, 3, 0, 126, 128, 5,
		3, 0, 0, 127, 126, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 130, 1, 0, 0,
		0, 129, 125, 1, 0, 0, 0, 130, 133, 1, 0, 0, 0, 131, 129, 1, 0, 0, 0, 131,
		132, 1, 0, 0, 0, 132, 5, 1, 0, 0, 0, 133, 131, 1, 0, 0, 0, 134, 135, 3,
		8, 4, 0, 135, 7, 1, 0, 0, 0, 136, 138, 3, 68, 34, 0, 137, 136, 1, 0, 0,
		0, 137, 138, 1, 0, 0, 0, 138, 139, 1, 0, 0, 0, 139, 140, 3, 10, 5, 0, 140,
		9, 1, 0, 0, 0, 141, 142, 6, 5, -1, 0, 142, 144, 3, 12, 6, 0, 143, 145,
		3, 26, 13, 0, 144, 143, 1, 0, 0, 0, 144, 145, 1, 0, 0, 0, 145, 147, 1,
		0, 0, 0, 146, 148, 3, 28, 14, 0, 147, 146, 1, 0, 0, 0, 147, 148, 1, 0,
		0, 0, 148, 159, 1, 0, 0, 0, 149, 150, 5, 121, 0, 0, 150, 151, 3, 10, 5,
		0, 151, 153, 5, 122, 0, 0, 152, 154, 3, 26, 13, 0, 153, 152, 1, 0, 0, 0,
		153, 154, 1, 0, 0, 0, 154, 156, 1, 0, 0, 0, 155, 157, 3, 28, 14, 0, 156,
		155, 1, 0, 0, 0, 156, 157, 1, 0, 0, 0, 157, 159, 1, 0, 0, 0, 158, 141,
		1, 0, 0, 0, 158, 149, 1, 0, 0, 0, 159, 171, 1, 0, 0, 0, 160, 161, 10, 1,
		0, 0, 161, 162, 3, 46, 23, 0, 162, 164, 3, 10, 5, 0, 163, 165, 3, 26, 13,
		0, 164, 163, 1, 0, 0, 0, 164, 165, 1, 0, 0, 0, 165, 167, 1, 0, 0, 0, 166,
		168, 3, 28, 14, 0, 167, 166, 1, 0, 0, 0, 167, 168, 1, 0, 0, 0, 168, 170,
		1, 0, 0, 0, 169, 160, 1, 0, 0, 0, 170, 173, 1, 0, 0, 0, 171, 169, 1, 0,
		0, 0, 171, 172, 1, 0, 0, 0, 172, 11, 1, 0, 0, 0, 173, 171, 1, 0, 0, 0,
		174, 176, 5, 86, 0, 0, 175, 177, 7, 0, 0, 0, 176, 175, 1, 0, 0, 0, 176,
		177, 1, 0, 0, 0, 177, 198, 1, 0, 0, 0, 178, 180, 3, 32, 16, 0, 179, 178,
		1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180, 182, 1, 0, 0, 0, 181, 183, 5, 119,
		0, 0, 182, 181, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 184, 1, 0, 0, 0,
		184, 186, 5, 136, 0, 0, 185, 187, 3, 38, 19, 0, 186, 185, 1, 0, 0, 0, 186,
		187, 1, 0, 0, 0, 187, 189, 1, 0, 0, 0, 188, 190, 3, 40, 20, 0, 189, 188,
		1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190, 199, 1, 0, 0, 0, 191, 196, 3, 32,
		16, 0, 192, 194, 5, 8, 0, 0, 193, 192, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0,
		194, 195, 1, 0, 0, 0, 195, 197, 3, 72, 36, 0, 196, 193, 1, 0, 0, 0, 196,
		197, 1, 0, 0, 0, 197, 199, 1, 0, 0, 0, 198, 179, 1, 0, 0, 0, 198, 191,
		1, 0, 0, 0, 199, 222, 1, 0, 0, 0, 200, 218, 5, 140, 0, 0, 201, 203, 3,
		32, 16, 0, 202, 201, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 204, 1, 0,
		0, 0, 204, 206, 5, 136, 0, 0, 205, 207, 3, 38, 19, 0, 206, 205, 1, 0, 0,
		0, 206, 207, 1, 0, 0, 0, 207, 209, 1, 0, 0, 0, 208, 210, 3, 40, 20, 0,
		209, 208, 1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 219, 1, 0, 0, 0, 211,
		216, 3, 32, 16, 0, 212, 214, 5, 8, 0, 0, 213, 212, 1, 0, 0, 0, 213, 214,
		1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 217, 3, 72, 36, 0, 216, 213, 1,
		0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 219, 1, 0, 0, 0, 218, 202, 1, 0, 0,
		0, 218, 211, 1, 0, 0, 0, 219, 221, 1, 0, 0, 0, 220, 200, 1, 0, 0, 0, 221,
		224, 1, 0, 0, 0, 222, 220, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0, 223, 226,
		1, 0, 0, 0, 224, 222, 1, 0, 0, 0, 225, 227, 3, 14, 7, 0, 226, 225, 1, 0,
		0, 0, 226, 227, 1, 0, 0, 0, 227, 229, 1, 0, 0, 0, 228, 230, 3, 18, 9, 0,
		229, 228, 1, 0, 0, 0, 229, 230, 1, 0, 0, 0, 230, 232, 1, 0, 0, 0, 231,
		233, 3, 20, 10, 0, 232, 231, 1, 0, 0, 0, 232, 233, 1, 0, 0, 0, 233, 235,
		1, 0, 0, 0, 234, 236, 3, 22, 11, 0, 235, 234, 1, 0, 0, 0, 235, 236, 1,
		0, 0, 0, 236, 238, 1, 0, 0, 0, 237, 239, 3, 24, 12, 0, 238, 237, 1, 0,
		0, 0, 238, 239, 1, 0, 0, 0, 239, 13, 1, 0, 0, 0, 240, 241, 5, 38, 0, 0,
		241, 246, 3, 16, 8, 0, 242, 243, 5, 140, 0, 0, 243, 245, 3, 16, 8, 0, 244,
		242, 1, 0, 0, 0, 245, 248, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 246, 247,
		1, 0, 0, 0, 247, 15, 1, 0, 0, 0, 248, 246, 1, 0, 0, 0, 249, 250, 6, 8,
		-1, 0, 250, 255, 3, 96, 48, 0, 251, 253, 5, 8, 0, 0, 252, 251, 1, 0, 0,
		0, 252, 253, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 256, 3, 72, 36, 0,
		255, 252, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256, 263, 1, 0, 0, 0, 257,
		258, 5, 37, 0, 0, 258, 259, 5, 90, 0, 0, 259, 260, 5, 93, 0, 0, 260, 261,
		5, 8, 0, 0, 261, 262, 5, 66, 0, 0, 262, 264, 3, 104, 52, 0, 263, 257, 1,
		0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 327, 1, 0, 0, 0, 265, 266, 5, 121,
		0, 0, 266, 267, 3, 8, 4, 0, 267, 272, 5, 122, 0, 0, 268, 270, 5, 8, 0,
		0, 269, 268, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 271, 1, 0, 0, 0, 271,
		273, 3, 72, 36, 0, 272, 269, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 327,
		1, 0, 0, 0, 274, 327, 3, 50, 25, 0, 275, 276, 5, 99, 0, 0, 276, 277, 5,
		121, 0, 0, 277, 278, 3, 54, 27, 0, 278, 283, 5, 122, 0, 0, 279, 281, 5,
		8, 0, 0, 280, 279, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 282, 1, 0, 0,
		0, 282, 284, 3, 72, 36, 0, 283, 280, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0,
		284, 291, 1, 0, 0, 0, 285, 286, 5, 104, 0, 0, 286, 288, 5, 67, 0, 0, 287,
		289, 5, 8, 0, 0, 288, 287, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 290,
		1, 0, 0, 0, 290, 292, 3, 72, 36, 0, 291, 285, 1, 0, 0, 0, 291, 292, 1,
		0, 0, 0, 292, 327, 1, 0, 0, 0, 293, 294, 5, 99, 0, 0, 294, 295, 5, 121,
		0, 0, 295, 296, 3, 56, 28, 0, 296, 301, 5, 122, 0, 0, 297, 299, 5, 8, 0,
		0, 298, 297, 1, 0, 0, 0, 298, 299, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300,
		302, 3, 72, 36, 0, 301, 298, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302, 309,
		1, 0, 0, 0, 303, 304, 5, 104, 0, 0, 304, 306, 5, 67, 0, 0, 305, 307, 5,
		8, 0, 0, 306, 305, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 308, 1, 0, 0,
		0, 308, 310, 3, 72, 36, 0, 309, 303, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0,
		310, 327, 1, 0, 0, 0, 311, 316, 3, 56, 28, 0, 312, 314, 5, 8, 0, 0, 313,
		312, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 317,
		3, 72, 36, 0, 316, 313, 1, 0, 0, 0, 316, 317, 1, 0, 0, 0, 317, 324, 1,
		0, 0, 0, 318, 319, 5, 104, 0, 0, 319, 321, 5, 67, 0, 0, 320, 322, 5, 8,
		0, 0, 321, 320, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0,
		323, 325, 3, 72, 36, 0, 324, 318, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325,
		327, 1, 0, 0, 0, 326, 249, 1, 0, 0, 0, 326, 265, 1, 0, 0, 0, 326, 274,
		1, 0, 0, 0, 326, 275, 1, 0, 0, 0, 326, 293, 1, 0, 0, 0, 326, 311, 1, 0,
		0, 0, 327, 340, 1, 0, 0, 0, 328, 330, 10, 6, 0, 0, 329, 331, 3, 42, 21,
		0, 330, 329, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332,
		333, 5, 53, 0, 0, 333, 336, 3, 16, 8, 0, 334, 337, 3, 44, 22, 0, 335, 337,
		3, 48, 24, 0, 336, 334, 1, 0, 0, 0, 336, 335, 1, 0, 0, 0, 337, 339, 1,
		0, 0, 0, 338, 328, 1, 0, 0, 0, 339, 342, 1, 0, 0, 0, 340, 338, 1, 0, 0,
		0, 340, 341, 1, 0, 0, 0, 341, 17, 1, 0, 0, 0, 342, 340, 1, 0, 0, 0, 343,
		344, 5, 102, 0, 0, 344, 345, 3, 58, 29, 0, 345, 19, 1, 0, 0, 0, 346, 347,
		5, 40, 0, 0, 347, 368, 5, 13, 0, 0, 348, 353, 3, 32, 16, 0, 349, 350, 5,
		140, 0, 0, 350, 352, 3, 32, 16, 0, 351, 349, 1, 0, 0, 0, 352, 355, 1, 0,
		0, 0, 353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 369, 1, 0, 0, 0,
		355, 353, 1, 0, 0, 0, 356, 357, 5, 82, 0, 0, 357, 358, 5, 121, 0, 0, 358,
		363, 3, 32, 16, 0, 359, 360, 5, 140, 0, 0, 360, 362, 3, 32, 16, 0, 361,
		359, 1, 0, 0, 0, 362, 365, 1, 0, 0, 0, 363, 361, 1, 0, 0, 0, 363, 364,
		1, 0, 0, 0, 364, 366, 1, 0, 0, 0, 365, 363, 1, 0, 0, 0, 366, 367, 5, 122,
		0, 0, 367, 369, 1, 0, 0, 0, 368, 348, 1, 0, 0, 0, 368, 356, 1, 0, 0, 0,
		369, 21, 1, 0, 0, 0, 370, 371, 5, 44, 0, 0, 371, 372, 3, 58, 29, 0, 372,
		23, 1, 0, 0, 0, 373, 374, 5, 103, 0, 0, 374, 375, 3, 60, 30, 0, 375, 376,
		5, 8, 0, 0, 376, 377, 5, 121, 0, 0, 377, 378, 3, 62, 31, 0, 378, 379, 5,
		122, 0, 0, 379, 25, 1, 0, 0, 0, 380, 381, 5, 70, 0, 0, 381, 382, 5, 13,
		0, 0, 382, 384, 3, 32, 16, 0, 383, 385, 7, 1, 0, 0, 384, 383, 1, 0, 0,
		0, 384, 385, 1, 0, 0, 0, 385, 393, 1, 0, 0, 0, 386, 387, 5, 140, 0, 0,
		387, 389, 3, 32, 16, 0, 388, 390, 7, 1, 0, 0, 389, 388, 1, 0, 0, 0, 389,
		390, 1, 0, 0, 0, 390, 392, 1, 0, 0, 0, 391, 386, 1, 0, 0, 0, 392, 395,
		1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0, 394, 27, 1, 0,
		0, 0, 395, 393, 1, 0, 0, 0, 396, 397, 5, 57, 0, 0, 397, 400, 3, 64, 32,
		0, 398, 399, 5, 67, 0, 0, 399, 401, 3, 66, 33, 0, 400, 398, 1, 0, 0, 0,
		400, 401, 1, 0, 0, 0, 401, 29, 1, 0, 0, 0, 402, 403, 7, 2, 0, 0, 403, 31,
		1, 0, 0, 0, 404, 405, 6, 16, -1, 0, 405, 462, 3, 98, 49, 0, 406, 462, 3,
		104, 52, 0, 407, 408, 3, 74, 37, 0, 408, 409, 5, 123, 0, 0, 409, 410, 7,
		3, 0, 0, 410, 411, 5, 121, 0, 0, 411, 412, 3, 32, 16, 0, 412, 413, 5, 122,
		0, 0, 413, 414, 5, 124, 0, 0, 414, 462, 1, 0, 0, 0, 415, 416, 3, 30, 15,
		0, 416, 417, 3, 32, 16, 20, 417, 462, 1, 0, 0, 0, 418, 420, 5, 52, 0, 0,
		419, 421, 5, 63, 0, 0, 420, 419, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421,
		422, 1, 0, 0, 0, 422, 462, 5, 96, 0, 0, 423, 425, 5, 52, 0, 0, 424, 426,
		5, 63, 0, 0, 425, 424, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 427, 1, 0,
		0, 0, 427, 462, 5, 34, 0, 0, 428, 429, 3, 84, 42, 0, 429, 439, 5, 121,
		0, 0, 430, 435, 3, 32, 16, 0, 431, 432, 5, 140, 0, 0, 432, 434, 3, 32,
		16, 0, 433, 431, 1, 0, 0, 0, 434, 437, 1, 0, 0, 0, 435, 433, 1, 0, 0, 0,
		435, 436, 1, 0, 0, 0, 436, 440, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 438,
		440, 5, 136, 0, 0, 439, 430, 1, 0, 0, 0, 439, 438, 1, 0, 0, 0, 440, 441,
		1, 0, 0, 0, 441, 442, 5, 122, 0, 0, 442, 462, 1, 0, 0, 0, 443, 462, 3,
		34, 17, 0, 444, 445, 5, 121, 0, 0, 445, 446, 3, 32, 16, 0, 446, 447, 5,
		122, 0, 0, 447, 462, 1, 0, 0, 0, 448, 449, 5, 123, 0, 0, 449, 454, 3, 32,
		16, 0, 450, 451, 5, 140, 0, 0, 451, 453, 3, 32, 16, 0, 452, 450, 1, 0,
		0, 0, 453, 456, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0,
		455, 457, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 457, 458, 5, 124, 0, 0, 458,
		462, 1, 0, 0, 0, 459, 462, 3, 36, 18, 0, 460, 462, 3, 118, 59, 0, 461,
		404, 1, 0, 0, 0, 461, 406, 1, 0, 0, 0, 461, 407, 1, 0, 0, 0, 461, 415,
		1, 0, 0, 0, 461, 418, 1, 0, 0, 0, 461, 423, 1, 0, 0, 0, 461, 428, 1, 0,
		0, 0, 461, 443, 1, 0, 0, 0, 461, 444, 1, 0, 0, 0, 461, 448, 1, 0, 0, 0,
		461, 459, 1, 0, 0, 0, 461, 460, 1, 0, 0, 0, 462, 542, 1, 0, 0, 0, 463,
		464, 10, 19, 0, 0, 464, 465, 7, 4, 0, 0, 465, 541, 3, 32, 16, 20, 466,
		467, 10, 18, 0, 0, 467, 468, 7, 5, 0, 0, 468, 541, 3, 32, 16, 19, 469,
		470, 10, 17, 0, 0, 470, 471, 7, 6, 0, 0, 471, 541, 3, 32, 16, 18, 472,
		473, 10, 16, 0, 0, 473, 474, 5, 134, 0, 0, 474, 541, 3, 32, 16, 17, 475,
		476, 10, 15, 0, 0, 476, 477, 5, 142, 0, 0, 477, 541, 3, 32, 16, 16, 478,
		479, 10, 14, 0, 0, 479, 480, 5, 135, 0, 0, 480, 541, 3, 32, 16, 15, 481,
		501, 10, 13, 0, 0, 482, 502, 5, 125, 0, 0, 483, 502, 5, 126, 0, 0, 484,
		502, 5, 127, 0, 0, 485, 502, 5, 130, 0, 0, 486, 502, 5, 131, 0, 0, 487,
		502, 5, 132, 0, 0, 488, 502, 5, 133, 0, 0, 489, 491, 5, 63, 0, 0, 490,
		489, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 502,
		5, 56, 0, 0, 493, 495, 5, 63, 0, 0, 494, 493, 1, 0, 0, 0, 494, 495, 1,
		0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 497, 5, 12, 0, 0, 497, 498, 3, 32,
		16, 0, 498, 499, 5, 5, 0, 0, 499, 500, 3, 32, 16, 0, 500, 502, 1, 0, 0,
		0, 501, 482, 1, 0, 0, 0, 501, 483, 1, 0, 0, 0, 501, 484, 1, 0, 0, 0, 501,
		485, 1, 0, 0, 0, 501, 486, 1, 0, 0, 0, 501, 487, 1, 0, 0, 0, 501, 488,
		1, 0, 0, 0, 501, 490, 1, 0, 0, 0, 501, 494, 1, 0, 0, 0, 502, 503, 1, 0,
		0, 0, 503, 541, 3, 32, 16, 14, 504, 505, 10, 8, 0, 0, 505, 506, 5, 5, 0,
		0, 506, 541, 3, 32, 16, 9, 507, 508, 10, 7, 0, 0, 508, 509, 5, 69, 0, 0,
		509, 541, 3, 32, 16, 8, 510, 511, 10, 12, 0, 0, 511, 513, 5, 52, 0, 0,
		512, 514, 5, 63, 0, 0, 513, 512, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0, 514,
		515, 1, 0, 0, 0, 515, 541, 5, 64, 0, 0, 516, 518, 10, 9, 0, 0, 517, 519,
		5, 63, 0, 0, 518, 517, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 520, 1, 0,
		0, 0, 520, 538, 5, 47, 0, 0, 521, 522, 5, 121, 0, 0, 522, 527, 3, 32, 16,
		0, 523, 524, 5, 140, 0, 0, 524, 526, 3, 32, 16, 0, 525, 523, 1, 0, 0, 0,
		526, 529, 1, 0, 0, 0, 527, 525, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528,
		530, 1, 0, 0, 0, 529, 527, 1, 0, 0, 0, 530, 531, 5, 122, 0, 0, 531, 539,
		1, 0, 0, 0, 532, 539, 3, 8, 4, 0, 533, 534, 5, 99, 0, 0, 534, 535, 5, 121,
		0, 0, 535, 536, 3, 54, 27, 0, 536, 537, 5, 122, 0, 0, 537, 539, 1, 0, 0,
		0, 538, 521, 1, 0, 0, 0, 538, 532, 1, 0, 0, 0, 538, 533, 1, 0, 0, 0, 539,
		541, 1, 0, 0, 0, 540, 463, 1, 0, 0, 0, 540, 466, 1, 0, 0, 0, 540, 469,
		1, 0, 0, 0, 540, 472, 1, 0, 0, 0, 540, 475, 1, 0, 0, 0, 540, 478, 1, 0,
		0, 0, 540, 481, 1, 0, 0, 0, 540, 504, 1, 0, 0, 0, 540, 507, 1, 0, 0, 0,
		540, 510, 1, 0, 0, 0, 540, 516, 1, 0, 0, 0, 541, 544, 1, 0, 0, 0, 542,
		540, 1, 0, 0, 0, 542, 543, 1, 0, 0, 0, 543, 33, 1, 0, 0, 0, 544, 542, 1,
		0, 0, 0, 545, 546, 5, 15, 0, 0, 546, 547, 5, 121, 0, 0, 547, 548, 3, 32,
		16, 0, 548, 549, 5, 8, 0, 0, 549, 550, 3, 82, 41, 0, 550, 551, 5, 122,
		0, 0, 551, 35, 1, 0, 0, 0, 552, 553, 5, 120, 0, 0, 553, 554, 3, 36, 18,
		0, 554, 555, 5, 120, 0, 0, 555, 573, 1, 0, 0, 0, 556, 557, 3, 90, 45, 0,
		557, 558, 5, 119, 0, 0, 558, 560, 1, 0, 0, 0, 559, 556, 1, 0, 0, 0, 559,
		560, 1, 0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 562, 3, 80, 40, 0, 562, 563,
		5, 119, 0, 0, 563, 565, 1, 0, 0, 0, 564, 559, 1, 0, 0, 0, 564, 565, 1,
		0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 567, 3, 94, 47, 0, 567, 568, 5, 119,
		0, 0, 568, 570, 1, 0, 0, 0, 569, 564, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0,
		570, 571, 1, 0, 0, 0, 571, 573, 3, 76, 38, 0, 572, 552, 1, 0, 0, 0, 572,
		569, 1, 0, 0, 0, 573, 37, 1, 0, 0, 0, 574, 575, 5, 30, 0, 0, 575, 576,
		5, 121, 0, 0, 576, 581, 3, 76, 38, 0, 577, 578, 5, 140, 0, 0, 578, 580,
		3, 76, 38, 0, 579, 577, 1, 0, 0, 0, 580, 583, 1, 0, 0, 0, 581, 579, 1,
		0, 0, 0, 581, 582, 1, 0, 0, 0, 582, 584, 1, 0, 0, 0, 583, 581, 1, 0, 0,
		0, 584, 585, 5, 122, 0, 0, 585, 39, 1, 0, 0, 0, 586, 587, 5, 79, 0, 0,
		587, 588, 5, 121, 0, 0, 588, 593, 3, 32, 16, 0, 589, 591, 5, 8, 0, 0, 590,
		589, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592, 594,
		3, 72, 36, 0, 593, 590, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 604, 1,
		0, 0, 0, 595, 596, 5, 140, 0, 0, 596, 598, 3, 32, 16, 0, 597, 599, 5, 8,
		0, 0, 598, 597, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0,
		600, 601, 3, 72, 36, 0, 601, 603, 1, 0, 0, 0, 602, 595, 1, 0, 0, 0, 603,
		606, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 607,
		1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 607, 608, 5, 122, 0, 0, 608, 41, 1, 0,
		0, 0, 609, 624, 5, 48, 0, 0, 610, 624, 5, 19, 0, 0, 611, 613, 5, 39, 0,
		0, 612, 614, 5, 72, 0, 0, 613, 612, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614,
		624, 1, 0, 0, 0, 615, 617, 5, 55, 0, 0, 616, 618, 5, 72, 0, 0, 617, 616,
		1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 624, 1, 0, 0, 0, 619, 621, 5, 81,
		0, 0, 620, 622, 5, 72, 0, 0, 621, 620, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0,
		622, 624, 1, 0, 0, 0, 623, 609, 1, 0, 0, 0, 623, 610, 1, 0, 0, 0, 623,
		611, 1, 0, 0, 0, 623, 615, 1, 0, 0, 0, 623, 619, 1, 0, 0, 0, 624, 43, 1,
		0, 0, 0, 625, 626, 5, 68, 0, 0, 626, 627, 3, 58, 29, 0, 627, 45, 1, 0,
		0, 0, 628, 630, 5, 98, 0, 0, 629, 631, 7, 0, 0, 0, 630, 629, 1, 0, 0, 0,
		630, 631, 1, 0, 0, 0, 631, 637, 1, 0, 0, 0, 632, 633, 5, 49, 0, 0, 633,
		637, 5, 25, 0, 0, 634, 635, 5, 30, 0, 0, 635, 637, 5, 25, 0, 0, 636, 628,
		1, 0, 0, 0, 636, 632, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 637, 47, 1, 0,
		0, 0, 638, 639, 5, 100, 0, 0, 639, 640, 5, 121, 0, 0, 640, 645, 3, 86,
		43, 0, 641, 642, 5, 140, 0, 0, 642, 644, 3, 86, 43, 0, 643, 641, 1, 0,
		0, 0, 644, 647, 1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0,
		646, 648, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 648, 649, 5, 122, 0, 0, 649,
		49, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 51, 1, 0, 0, 0, 652, 653, 5,
		89, 0, 0, 653, 654, 5, 126, 0, 0, 654, 655, 3, 82, 41, 0, 655, 656, 5,
		127, 0, 0, 656, 53, 1, 0, 0, 0, 657, 658, 5, 7, 0, 0, 658, 659, 5, 126,
		0, 0, 659, 660, 3, 82, 41, 0, 660, 661, 5, 127, 0, 0, 661, 55, 1, 0, 0,
		0, 662, 663, 1, 0, 0, 0, 663, 57, 1, 0, 0, 0, 664, 665, 3, 32, 16, 0, 665,
		59, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 61, 1, 0, 0, 0, 668, 669, 1,
		0, 0, 0, 669, 63, 1, 0, 0, 0, 670, 671, 3, 98, 49, 0, 671, 65, 1, 0, 0,
		0, 672, 673, 3, 98, 49, 0, 673, 67, 1, 0, 0, 0, 674, 675, 5, 104, 0, 0,
		675, 676, 3, 78, 39, 0, 676, 677, 5, 8, 0, 0, 677, 678, 5, 121, 0, 0, 678,
		679, 3, 10, 5, 0, 679, 689, 5, 122, 0, 0, 680, 681, 5, 140, 0, 0, 681,
		682, 3, 78, 39, 0, 682, 683, 5, 8, 0, 0, 683, 684, 5, 121, 0, 0, 684, 685,
		3, 10, 5, 0, 685, 686, 5, 122, 0, 0, 686, 688, 1, 0, 0, 0, 687, 680, 1,
		0, 0, 0, 688, 691, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689, 690, 1, 0, 0,
		0, 690, 69, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 692, 710, 5, 117, 0, 0, 693,
		694, 5, 2, 0, 0, 694, 695, 3, 70, 35, 0, 695, 696, 5, 2, 0, 0, 696, 710,
		1, 0, 0, 0, 697, 698, 5, 121, 0, 0, 698, 699, 3, 70, 35, 0, 699, 700, 5,
		122, 0, 0, 700, 710, 1, 0, 0, 0, 701, 702, 5, 120, 0, 0, 702, 703, 3, 70,
		35, 0, 703, 704, 5, 120, 0, 0, 704, 710, 1, 0, 0, 0, 705, 706, 5, 1, 0,
		0, 706, 707, 3, 70, 35, 0, 707, 708, 5, 1, 0, 0, 708, 710, 1, 0, 0, 0,
		709, 692, 1, 0, 0, 0, 709, 693, 1, 0, 0, 0, 709, 697, 1, 0, 0, 0, 709,
		701, 1, 0, 0, 0, 709, 705, 1, 0, 0, 0, 710, 71, 1, 0, 0, 0, 711, 712, 3,
		70, 35, 0, 712, 73, 1, 0, 0, 0, 713, 714, 3, 70, 35, 0, 714, 75, 1, 0,
		0, 0, 715, 716, 3, 70, 35, 0, 716, 77, 1, 0, 0, 0, 717, 718, 3, 70, 35,
		0, 718, 79, 1, 0, 0, 0, 719, 720, 3, 70, 35, 0, 720, 81, 1, 0, 0, 0, 721,
		722, 3, 70, 35, 0, 722, 83, 1, 0, 0, 0, 723, 724, 3, 70, 35, 0, 724, 85,
		1, 0, 0, 0, 725, 726, 3, 70, 35, 0, 726, 87, 1, 0, 0, 0, 727, 728, 3, 70,
		35, 0, 728, 89, 1, 0, 0, 0, 729, 730, 3, 70, 35, 0, 730, 91, 1, 0, 0, 0,
		731, 732, 3, 70, 35, 0, 732, 93, 1, 0, 0, 0, 733, 734, 3, 70, 35, 0, 734,
		95, 1, 0, 0, 0, 735, 736, 3, 90, 45, 0, 736, 737, 5, 119, 0, 0, 737, 739,
		1, 0, 0, 0, 738, 735, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 740, 1, 0,
		0, 0, 740, 741, 3, 80, 40, 0, 741, 742, 5, 119, 0, 0, 742, 744, 1, 0, 0,
		0, 743, 738, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745,
		751, 3, 94, 47, 0, 746, 747, 5, 120, 0, 0, 747, 748, 3, 96, 48, 0, 748,
		749, 5, 120, 0, 0, 749, 751, 1, 0, 0, 0, 750, 743, 1, 0, 0, 0, 750, 746,
		1, 0, 0, 0, 751, 97, 1, 0, 0, 0, 752, 755, 3, 100, 50, 0, 753, 755, 3,
		102, 51, 0, 754, 752, 1, 0, 0, 0, 754, 753, 1, 0, 0, 0, 755, 99, 1, 0,
		0, 0, 756, 757, 5, 106, 0, 0, 757, 101, 1, 0, 0, 0, 758, 759, 5, 107, 0,
		0, 759, 103, 1, 0, 0, 0, 760, 767, 3, 106, 53, 0, 761, 767, 3, 108, 54,
		0, 762, 767, 3, 110, 55, 0, 763, 767, 3, 112, 56, 0, 764, 767, 3, 114,
		57, 0, 765, 767, 3, 116, 58, 0, 766, 760, 1, 0, 0, 0, 766, 761, 1, 0, 0,
		0, 766, 762, 1, 0, 0, 0, 766, 763, 1, 0, 0, 0, 766, 764, 1, 0, 0, 0, 766,
		765, 1, 0, 0, 0, 767, 105, 1, 0, 0, 0, 768, 769, 5, 112, 0, 0, 769, 107,
		1, 0, 0, 0, 770, 771, 5, 113, 0, 0, 771, 109, 1, 0, 0, 0, 772, 773, 5,
		114, 0, 0, 773, 111, 1, 0, 0, 0, 774, 775, 5, 115, 0, 0, 775, 113, 1, 0,
		0, 0, 776, 777, 5, 116, 0, 0, 777, 115, 1, 0, 0, 0, 778, 779, 3, 82, 41,
		0, 779, 780, 5, 112, 0, 0, 780, 117, 1, 0, 0, 0, 781, 782, 7, 7, 0, 0,
		782, 119, 1, 0, 0, 0, 98, 127, 131, 137, 144, 147, 153, 156, 158, 164,
		167, 171, 176, 179, 182, 186, 189, 193, 196, 198, 202, 206, 209, 213, 216,
		218, 222, 226, 229, 232, 235, 238, 246, 252, 255, 263, 269, 272, 280, 283,
		288, 291, 298, 301, 306, 309, 313, 316, 321, 324, 326, 330, 336, 340, 353,
		363, 368, 384, 389, 393, 400, 420, 425, 435, 439, 454, 461, 490, 494, 501,
		513, 518, 527, 538, 540, 542, 559, 564, 569, 572, 581, 590, 593, 598, 604,
		613, 617, 621, 623, 630, 636, 645, 689, 709, 738, 743, 750, 754, 766,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// BigQueryParserInit initializes any static state used to implement BigQueryParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewBigQueryParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BigQueryParserInit() {
	staticData := &BigQueryParserParserStaticData
	staticData.once.Do(bigqueryparserParserInit)
}

// NewBigQueryParser produces a new parser instance for the optional input antlr.TokenStream.
func NewBigQueryParser(input antlr.TokenStream) *BigQueryParser {
	BigQueryParserInit()
	this := new(BigQueryParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &BigQueryParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "BigQueryParser.g4"

	return this
}

// BigQueryParser tokens.
const (
	BigQueryParserEOF                  = antlr.TokenEOF
	BigQueryParserQUOTE                = 1
	BigQueryParserDQOUTE               = 2
	BigQueryParserSEMI                 = 3
	BigQueryParserALL                  = 4
	BigQueryParserAND                  = 5
	BigQueryParserANY                  = 6
	BigQueryParserARRAY                = 7
	BigQueryParserAS                   = 8
	BigQueryParserASC                  = 9
	BigQueryParserASSERT_ROWS_MODIFIED = 10
	BigQueryParserAT                   = 11
	BigQueryParserBETWEEN              = 12
	BigQueryParserBY                   = 13
	BigQueryParserCASE                 = 14
	BigQueryParserCAST                 = 15
	BigQueryParserCOLLATE              = 16
	BigQueryParserCONTAINS             = 17
	BigQueryParserCREATE               = 18
	BigQueryParserCROSS                = 19
	BigQueryParserCUBE                 = 20
	BigQueryParserCURRENT              = 21
	BigQueryParserDEFAULT              = 22
	BigQueryParserDEFINE               = 23
	BigQueryParserDESC                 = 24
	BigQueryParserDISTINCT             = 25
	BigQueryParserELSE                 = 26
	BigQueryParserEND                  = 27
	BigQueryParserENUM                 = 28
	BigQueryParserESCAPE               = 29
	BigQueryParserEXCEPT               = 30
	BigQueryParserEXCLUDE              = 31
	BigQueryParserEXISTS               = 32
	BigQueryParserEXTRACT              = 33
	BigQueryParserFALSE                = 34
	BigQueryParserFETCH                = 35
	BigQueryParserFOLLOWING            = 36
	BigQueryParserFOR                  = 37
	BigQueryParserFROM                 = 38
	BigQueryParserFULL                 = 39
	BigQueryParserGROUP                = 40
	BigQueryParserGROUPING             = 41
	BigQueryParserGROUPS               = 42
	BigQueryParserHASH                 = 43
	BigQueryParserHAVING               = 44
	BigQueryParserIF                   = 45
	BigQueryParserIGNORE               = 46
	BigQueryParserIN                   = 47
	BigQueryParserINNER                = 48
	BigQueryParserINTERSECT            = 49
	BigQueryParserINTERVAL             = 50
	BigQueryParserINTO                 = 51
	BigQueryParserIS                   = 52
	BigQueryParserJOIN                 = 53
	BigQueryParserLATERAL              = 54
	BigQueryParserLEFT                 = 55
	BigQueryParserLIKE                 = 56
	BigQueryParserLIMIT                = 57
	BigQueryParserLOOKUP               = 58
	BigQueryParserMERGE                = 59
	BigQueryParserNATURAL              = 60
	BigQueryParserNEW                  = 61
	BigQueryParserNO                   = 62
	BigQueryParserNOT                  = 63
	BigQueryParserS_NULL               = 64
	BigQueryParserNULLS                = 65
	BigQueryParserOF                   = 66
	BigQueryParserOFFSET               = 67
	BigQueryParserON                   = 68
	BigQueryParserOR                   = 69
	BigQueryParserORDER                = 70
	BigQueryParserORDINAL              = 71
	BigQueryParserOUTER                = 72
	BigQueryParserOVER                 = 73
	BigQueryParserPARTITION            = 74
	BigQueryParserPRECEDING            = 75
	BigQueryParserPROTO                = 76
	BigQueryParserRANGE                = 77
	BigQueryParserRECURSIVE            = 78
	BigQueryParserREPLACE              = 79
	BigQueryParserRESPECT              = 80
	BigQueryParserRIGHT                = 81
	BigQueryParserROLLUP               = 82
	BigQueryParserROWS                 = 83
	BigQueryParserSAFE_OFFSET          = 84
	BigQueryParserSAFE_ORDINAL         = 85
	BigQueryParserSELECT               = 86
	BigQueryParserSET                  = 87
	BigQueryParserSOME                 = 88
	BigQueryParserSSTRUCT              = 89
	BigQueryParserSYSTEM               = 90
	BigQueryParserTABLESAMPLE          = 91
	BigQueryParserTHEN                 = 92
	BigQueryParserTIME                 = 93
	BigQueryParserTO                   = 94
	BigQueryParserTREAT                = 95
	BigQueryParserTRUE                 = 96
	BigQueryParserUNBOUNDED            = 97
	BigQueryParserUNION                = 98
	BigQueryParserUNNEST               = 99
	BigQueryParserUSING                = 100
	BigQueryParserWHEN                 = 101
	BigQueryParserWHERE                = 102
	BigQueryParserWINDOW               = 103
	BigQueryParserWITH                 = 104
	BigQueryParserWITHIN               = 105
	BigQueryParserINT                  = 106
	BigQueryParserFLOAT                = 107
	BigQueryParserDIGITS               = 108
	BigQueryParserWS                   = 109
	BigQueryParserCMT                  = 110
	BigQueryParserM_CMT                = 111
	BigQueryParserQUOTED_STRING        = 112
	BigQueryParserTRIPLE_QUOTED_STRING = 113
	BigQueryParserRAW_STRING           = 114
	BigQueryParserBYTE_STRING          = 115
	BigQueryParserRAW_BYTE_STRING      = 116
	BigQueryParserID                   = 117
	BigQueryParserRB                   = 118
	BigQueryParserDOT                  = 119
	BigQueryParserBACKTICK             = 120
	BigQueryParserLR_BRACKET           = 121
	BigQueryParserRR_BRACKET           = 122
	BigQueryParserLSB                  = 123
	BigQueryParserRSB                  = 124
	BigQueryParserEQ                   = 125
	BigQueryParserLT                   = 126
	BigQueryParserGT                   = 127
	BigQueryParserDOUBLE_LT            = 128
	BigQueryParserDOUBLE_GT            = 129
	BigQueryParserLE                   = 130
	BigQueryParserGE                   = 131
	BigQueryParserNE                   = 132
	BigQueryParserLTGT                 = 133
	BigQueryParserBIT_AND              = 134
	BigQueryParserBIT_OR               = 135
	BigQueryParserSTAR                 = 136
	BigQueryParserDIVIDE               = 137
	BigQueryParserPLUS                 = 138
	BigQueryParserMINUS                = 139
	BigQueryParserCOMMA                = 140
	BigQueryParserTILDE                = 141
	BigQueryParserCARET                = 142
)

// BigQueryParser rules.
const (
	BigQueryParserRULE_root                 = 0
	BigQueryParserRULE_stmtblock            = 1
	BigQueryParserRULE_stmtmulti            = 2
	BigQueryParserRULE_stmt                 = 3
	BigQueryParserRULE_query_statement      = 4
	BigQueryParserRULE_query_expr           = 5
	BigQueryParserRULE_select_statement     = 6
	BigQueryParserRULE_from_statement       = 7
	BigQueryParserRULE_from_item            = 8
	BigQueryParserRULE_where_statement      = 9
	BigQueryParserRULE_group_statement      = 10
	BigQueryParserRULE_having_statement     = 11
	BigQueryParserRULE_window_statement     = 12
	BigQueryParserRULE_order_clause         = 13
	BigQueryParserRULE_limit_clause         = 14
	BigQueryParserRULE_unary_operator       = 15
	BigQueryParserRULE_expr                 = 16
	BigQueryParserRULE_cast_expr            = 17
	BigQueryParserRULE_column_expr          = 18
	BigQueryParserRULE_except_statement     = 19
	BigQueryParserRULE_replace_statement    = 20
	BigQueryParserRULE_join_type            = 21
	BigQueryParserRULE_on_clause            = 22
	BigQueryParserRULE_set_op               = 23
	BigQueryParserRULE_using_clause         = 24
	BigQueryParserRULE_field_path           = 25
	BigQueryParserRULE_sstruct              = 26
	BigQueryParserRULE_array_expr           = 27
	BigQueryParserRULE_array_path           = 28
	BigQueryParserRULE_bool_expression      = 29
	BigQueryParserRULE_window_name          = 30
	BigQueryParserRULE_window_definition    = 31
	BigQueryParserRULE_count                = 32
	BigQueryParserRULE_skip_rows            = 33
	BigQueryParserRULE_with_statement       = 34
	BigQueryParserRULE_name                 = 35
	BigQueryParserRULE_alias_name           = 36
	BigQueryParserRULE_array_name           = 37
	BigQueryParserRULE_column_name          = 38
	BigQueryParserRULE_cte_name             = 39
	BigQueryParserRULE_dataset_name         = 40
	BigQueryParserRULE_datatype_name        = 41
	BigQueryParserRULE_function_name        = 42
	BigQueryParserRULE_join_name            = 43
	BigQueryParserRULE_member_name          = 44
	BigQueryParserRULE_project_name         = 45
	BigQueryParserRULE_struct_name          = 46
	BigQueryParserRULE_table_name           = 47
	BigQueryParserRULE_table_expr           = 48
	BigQueryParserRULE_number               = 49
	BigQueryParserRULE_integer_type         = 50
	BigQueryParserRULE_float_type           = 51
	BigQueryParserRULE_string               = 52
	BigQueryParserRULE_quoted_string        = 53
	BigQueryParserRULE_triple_quoted_string = 54
	BigQueryParserRULE_raw_string           = 55
	BigQueryParserRULE_byte_string          = 56
	BigQueryParserRULE_raw_byte_string      = 57
	BigQueryParserRULE_special_string       = 58
	BigQueryParserRULE_keyword              = 59
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmtblock() IStmtblockContext
	EOF() antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) Stmtblock() IStmtblockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtblockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtblockContext)
}

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEOF, 0)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, BigQueryParserRULE_root)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(120)
		p.Stmtblock()
	}
	{
		p.SetState(121)
		p.Match(BigQueryParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtblockContext is an interface to support dynamic dispatch.
type IStmtblockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmtmulti() IStmtmultiContext

	// IsStmtblockContext differentiates from other interfaces.
	IsStmtblockContext()
}

type StmtblockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtblockContext() *StmtblockContext {
	var p = new(StmtblockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmtblock
	return p
}

func InitEmptyStmtblockContext(p *StmtblockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmtblock
}

func (*StmtblockContext) IsStmtblockContext() {}

func NewStmtblockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtblockContext {
	var p = new(StmtblockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_stmtblock

	return p
}

func (s *StmtblockContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtblockContext) Stmtmulti() IStmtmultiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtmultiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtmultiContext)
}

func (s *StmtblockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtblockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtblockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterStmtblock(s)
	}
}

func (s *StmtblockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitStmtblock(s)
	}
}

func (s *StmtblockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitStmtblock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Stmtblock() (localctx IStmtblockContext) {
	localctx = NewStmtblockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, BigQueryParserRULE_stmtblock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(123)
		p.Stmtmulti()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtmultiContext is an interface to support dynamic dispatch.
type IStmtmultiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStmtmultiContext differentiates from other interfaces.
	IsStmtmultiContext()
}

type StmtmultiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtmultiContext() *StmtmultiContext {
	var p = new(StmtmultiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmtmulti
	return p
}

func InitEmptyStmtmultiContext(p *StmtmultiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmtmulti
}

func (*StmtmultiContext) IsStmtmultiContext() {}

func NewStmtmultiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtmultiContext {
	var p = new(StmtmultiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_stmtmulti

	return p
}

func (s *StmtmultiContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtmultiContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *StmtmultiContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *StmtmultiContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserSEMI)
}

func (s *StmtmultiContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserSEMI, i)
}

func (s *StmtmultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtmultiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtmultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterStmtmulti(s)
	}
}

func (s *StmtmultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitStmtmulti(s)
	}
}

func (s *StmtmultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitStmtmulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Stmtmulti() (localctx IStmtmultiContext) {
	localctx = NewStmtmultiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, BigQueryParserRULE_stmtmulti)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&34360000513) != 0 {
		{
			p.SetState(125)
			p.Stmt()
		}
		p.SetState(127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserSEMI {
			{
				p.SetState(126)
				p.Match(BigQueryParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_statement() IQuery_statementContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, BigQueryParserRULE_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(134)
		p.Query_statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_statementContext is an interface to support dynamic dispatch.
type IQuery_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_expr() IQuery_exprContext
	With_statement() IWith_statementContext

	// IsQuery_statementContext differentiates from other interfaces.
	IsQuery_statementContext()
}

type Query_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_statementContext() *Query_statementContext {
	var p = new(Query_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_query_statement
	return p
}

func InitEmptyQuery_statementContext(p *Query_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_query_statement
}

func (*Query_statementContext) IsQuery_statementContext() {}

func NewQuery_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_statementContext {
	var p = new(Query_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_query_statement

	return p
}

func (s *Query_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_statementContext) Query_expr() IQuery_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *Query_statementContext) With_statement() IWith_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_statementContext)
}

func (s *Query_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterQuery_statement(s)
	}
}

func (s *Query_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitQuery_statement(s)
	}
}

func (s *Query_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitQuery_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Query_statement() (localctx IQuery_statementContext) {
	localctx = NewQuery_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, BigQueryParserRULE_query_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == BigQueryParserWITH {
		{
			p.SetState(136)
			p.With_statement()
		}

	}
	{
		p.SetState(139)
		p.query_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_exprContext is an interface to support dynamic dispatch.
type IQuery_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_statement() ISelect_statementContext
	Order_clause() IOrder_clauseContext
	Limit_clause() ILimit_clauseContext
	LR_BRACKET() antlr.TerminalNode
	AllQuery_expr() []IQuery_exprContext
	Query_expr(i int) IQuery_exprContext
	RR_BRACKET() antlr.TerminalNode
	Set_op() ISet_opContext

	// IsQuery_exprContext differentiates from other interfaces.
	IsQuery_exprContext()
}

type Query_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_exprContext() *Query_exprContext {
	var p = new(Query_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_query_expr
	return p
}

func InitEmptyQuery_exprContext(p *Query_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_query_expr
}

func (*Query_exprContext) IsQuery_exprContext() {}

func NewQuery_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_exprContext {
	var p = new(Query_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_query_expr

	return p
}

func (s *Query_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Query_exprContext) Order_clause() IOrder_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_clauseContext)
}

func (s *Query_exprContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Query_exprContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Query_exprContext) AllQuery_expr() []IQuery_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_exprContext); ok {
			len++
		}
	}

	tst := make([]IQuery_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_exprContext); ok {
			tst[i] = t.(IQuery_exprContext)
			i++
		}
	}

	return tst
}

func (s *Query_exprContext) Query_expr(i int) IQuery_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *Query_exprContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Query_exprContext) Set_op() ISet_opContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_opContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_opContext)
}

func (s *Query_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterQuery_expr(s)
	}
}

func (s *Query_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitQuery_expr(s)
	}
}

func (s *Query_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitQuery_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Query_expr() (localctx IQuery_exprContext) {
	return p.query_expr(0)
}

func (p *BigQueryParser) query_expr(_p int) (localctx IQuery_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQuery_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQuery_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, BigQueryParserRULE_query_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserSELECT:
		{
			p.SetState(142)
			p.Select_statement()
		}
		p.SetState(144)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(143)
				p.Order_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(147)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(146)
				p.Limit_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case BigQueryParserLR_BRACKET:
		{
			p.SetState(149)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(150)
			p.query_expr(0)
		}
		{
			p.SetState(151)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(153)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(152)
				p.Order_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(156)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(155)
				p.Limit_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewQuery_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_query_expr)
			p.SetState(160)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(161)
				p.Set_op()
			}
			{
				p.SetState(162)
				p.query_expr(0)
			}
			p.SetState(164)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(163)
					p.Order_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(167)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(166)
					p.Limit_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	From_statement() IFrom_statementContext
	Where_statement() IWhere_statementContext
	Group_statement() IGroup_statementContext
	Having_statement() IHaving_statementContext
	Window_statement() IWindow_statementContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	DOT() antlr.TerminalNode
	AllExcept_statement() []IExcept_statementContext
	Except_statement(i int) IExcept_statementContext
	AllReplace_statement() []IReplace_statementContext
	Replace_statement(i int) IReplace_statementContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_select_statement
	return p
}

func InitEmptySelect_statementContext(p *Select_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_select_statement
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSELECT, 0)
}

func (s *Select_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Select_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Select_statementContext) From_statement() IFrom_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_statementContext)
}

func (s *Select_statementContext) Where_statement() IWhere_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_statementContext)
}

func (s *Select_statementContext) Group_statement() IGroup_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_statementContext)
}

func (s *Select_statementContext) Having_statement() IHaving_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_statementContext)
}

func (s *Select_statementContext) Window_statement() IWindow_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_statementContext)
}

func (s *Select_statementContext) ALL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserALL, 0)
}

func (s *Select_statementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDISTINCT, 0)
}

func (s *Select_statementContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserSTAR)
}

func (s *Select_statementContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserSTAR, i)
}

func (s *Select_statementContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *Select_statementContext) DOT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDOT, 0)
}

func (s *Select_statementContext) AllExcept_statement() []IExcept_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExcept_statementContext); ok {
			len++
		}
	}

	tst := make([]IExcept_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExcept_statementContext); ok {
			tst[i] = t.(IExcept_statementContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Except_statement(i int) IExcept_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcept_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcept_statementContext)
}

func (s *Select_statementContext) AllReplace_statement() []IReplace_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplace_statementContext); ok {
			len++
		}
	}

	tst := make([]IReplace_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplace_statementContext); ok {
			tst[i] = t.(IReplace_statementContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Replace_statement(i int) IReplace_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_statementContext)
}

func (s *Select_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserAS)
}

func (s *Select_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, i)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterSelect_statement(s)
	}
}

func (s *Select_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitSelect_statement(s)
	}
}

func (s *Select_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitSelect_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, BigQueryParserRULE_select_statement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)
		p.Match(BigQueryParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(175)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BigQueryParserALL || _la == BigQueryParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.SetState(179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-10) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&810384050136023039) != 0) || _la == BigQueryParserMINUS || _la == BigQueryParserTILDE {
			{
				p.SetState(178)
				p.expr(0)
			}

		}
		p.SetState(182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserDOT {
			{
				p.SetState(181)
				p.Match(BigQueryParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(184)
			p.Match(BigQueryParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(186)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(185)
				p.Except_statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(189)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(188)
				p.Replace_statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(191)
			p.expr(0)
		}
		p.SetState(196)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			p.SetState(193)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(192)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(195)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(200)
				p.Match(BigQueryParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(218)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
			case 1:
				p.SetState(202)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-10) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&810384050136023039) != 0) || _la == BigQueryParserMINUS || _la == BigQueryParserTILDE {
					{
						p.SetState(201)
						p.expr(0)
					}

				}
				{
					p.SetState(204)
					p.Match(BigQueryParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(206)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(205)
						p.Except_statement()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(209)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(208)
						p.Replace_statement()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 2:
				{
					p.SetState(211)
					p.expr(0)
				}
				p.SetState(216)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
					p.SetState(213)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == BigQueryParserAS {
						{
							p.SetState(212)
							p.Match(BigQueryParserAS)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(215)
						p.Alias_name()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(225)
			p.From_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(228)
			p.Where_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(231)
			p.Group_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(234)
			p.Having_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(237)
			p.Window_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_statementContext is an interface to support dynamic dispatch.
type IFrom_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	AllFrom_item() []IFrom_itemContext
	From_item(i int) IFrom_itemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFrom_statementContext differentiates from other interfaces.
	IsFrom_statementContext()
}

type From_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_statementContext() *From_statementContext {
	var p = new(From_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_from_statement
	return p
}

func InitEmptyFrom_statementContext(p *From_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_from_statement
}

func (*From_statementContext) IsFrom_statementContext() {}

func NewFrom_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_statementContext {
	var p = new(From_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_from_statement

	return p
}

func (s *From_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *From_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFROM, 0)
}

func (s *From_statementContext) AllFrom_item() []IFrom_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_itemContext); ok {
			len++
		}
	}

	tst := make([]IFrom_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_itemContext); ok {
			tst[i] = t.(IFrom_itemContext)
			i++
		}
	}

	return tst
}

func (s *From_statementContext) From_item(i int) IFrom_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_itemContext)
}

func (s *From_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *From_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *From_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterFrom_statement(s)
	}
}

func (s *From_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitFrom_statement(s)
	}
}

func (s *From_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitFrom_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) From_statement() (localctx IFrom_statementContext) {
	localctx = NewFrom_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, BigQueryParserRULE_from_statement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(240)
		p.Match(BigQueryParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(241)
		p.from_item(0)
	}
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(242)
				p.Match(BigQueryParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(243)
				p.from_item(0)
			}

		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_itemContext is an interface to support dynamic dispatch.
type IFrom_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_expr() ITable_exprContext
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	FOR() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TIME() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	OF() antlr.TerminalNode
	String_() IStringContext
	LR_BRACKET() antlr.TerminalNode
	Query_statement() IQuery_statementContext
	RR_BRACKET() antlr.TerminalNode
	Field_path() IField_pathContext
	UNNEST() antlr.TerminalNode
	Array_expr() IArray_exprContext
	WITH() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	Array_path() IArray_pathContext
	AllFrom_item() []IFrom_itemContext
	From_item(i int) IFrom_itemContext
	JOIN() antlr.TerminalNode
	On_clause() IOn_clauseContext
	Using_clause() IUsing_clauseContext
	Join_type() IJoin_typeContext

	// IsFrom_itemContext differentiates from other interfaces.
	IsFrom_itemContext()
}

type From_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_itemContext() *From_itemContext {
	var p = new(From_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_from_item
	return p
}

func InitEmptyFrom_itemContext(p *From_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_from_item
}

func (*From_itemContext) IsFrom_itemContext() {}

func NewFrom_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_itemContext {
	var p = new(From_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_from_item

	return p
}

func (s *From_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *From_itemContext) Table_expr() ITable_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_exprContext)
}

func (s *From_itemContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *From_itemContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *From_itemContext) FOR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFOR, 0)
}

func (s *From_itemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSYSTEM, 0)
}

func (s *From_itemContext) TIME() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTIME, 0)
}

func (s *From_itemContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserAS)
}

func (s *From_itemContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, i)
}

func (s *From_itemContext) OF() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOF, 0)
}

func (s *From_itemContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *From_itemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *From_itemContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *From_itemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *From_itemContext) Field_path() IField_pathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_pathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_pathContext)
}

func (s *From_itemContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNNEST, 0)
}

func (s *From_itemContext) Array_expr() IArray_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_exprContext)
}

func (s *From_itemContext) WITH() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWITH, 0)
}

func (s *From_itemContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOFFSET, 0)
}

func (s *From_itemContext) Array_path() IArray_pathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_pathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_pathContext)
}

func (s *From_itemContext) AllFrom_item() []IFrom_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_itemContext); ok {
			len++
		}
	}

	tst := make([]IFrom_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_itemContext); ok {
			tst[i] = t.(IFrom_itemContext)
			i++
		}
	}

	return tst
}

func (s *From_itemContext) From_item(i int) IFrom_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_itemContext)
}

func (s *From_itemContext) JOIN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserJOIN, 0)
}

func (s *From_itemContext) On_clause() IOn_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_clauseContext)
}

func (s *From_itemContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *From_itemContext) Join_type() IJoin_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_typeContext)
}

func (s *From_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterFrom_item(s)
	}
}

func (s *From_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitFrom_item(s)
	}
}

func (s *From_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitFrom_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) From_item() (localctx IFrom_itemContext) {
	return p.from_item(0)
}

func (p *BigQueryParser) from_item(_p int) (localctx IFrom_itemContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFrom_itemContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFrom_itemContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 16
	p.EnterRecursionRule(localctx, 16, BigQueryParserRULE_from_item, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(250)
			p.Table_expr()
		}
		p.SetState(255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			p.SetState(252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(251)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(254)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(257)
				p.Match(BigQueryParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(258)
				p.Match(BigQueryParserSYSTEM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(259)
				p.Match(BigQueryParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(260)
				p.Match(BigQueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(261)
				p.Match(BigQueryParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(262)
				p.String_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(265)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(266)
			p.Query_statement()
		}
		{
			p.SetState(267)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(272)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			p.SetState(269)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(268)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(271)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(274)
			p.Field_path()
		}

	case 4:
		{
			p.SetState(275)
			p.Match(BigQueryParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(276)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)
			p.Array_expr()
		}
		{
			p.SetState(278)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(283)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			p.SetState(280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(279)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(282)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(285)
				p.Match(BigQueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(286)
				p.Match(BigQueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(288)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(287)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(290)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		{
			p.SetState(293)
			p.Match(BigQueryParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(294)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(295)
			p.Array_path()
		}
		{
			p.SetState(296)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(297)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(300)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(303)
				p.Match(BigQueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(304)
				p.Match(BigQueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(306)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(305)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(308)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		{
			p.SetState(311)
			p.Array_path()
		}
		p.SetState(316)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			p.SetState(313)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(312)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(315)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(318)
				p.Match(BigQueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(319)
				p.Match(BigQueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(321)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == BigQueryParserAS {
				{
					p.SetState(320)
					p.Match(BigQueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(323)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFrom_itemContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_from_item)
			p.SetState(328)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				goto errorExit
			}
			p.SetState(330)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-19)) & ^0x3f) == 0 && ((int64(1)<<(_la-19))&4611686087684784129) != 0 {
				{
					p.SetState(329)
					p.Join_type()
				}

			}
			{
				p.SetState(332)
				p.Match(BigQueryParserJOIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(333)
				p.from_item(0)
			}
			p.SetState(336)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case BigQueryParserON:
				{
					p.SetState(334)
					p.On_clause()
				}

			case BigQueryParserUSING:
				{
					p.SetState(335)
					p.Using_clause()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhere_statementContext is an interface to support dynamic dispatch.
type IWhere_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsWhere_statementContext differentiates from other interfaces.
	IsWhere_statementContext()
}

type Where_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_statementContext() *Where_statementContext {
	var p = new(Where_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_where_statement
	return p
}

func InitEmptyWhere_statementContext(p *Where_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_where_statement
}

func (*Where_statementContext) IsWhere_statementContext() {}

func NewWhere_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_statementContext {
	var p = new(Where_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_where_statement

	return p
}

func (s *Where_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWHERE, 0)
}

func (s *Where_statementContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *Where_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterWhere_statement(s)
	}
}

func (s *Where_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitWhere_statement(s)
	}
}

func (s *Where_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitWhere_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Where_statement() (localctx IWhere_statementContext) {
	localctx = NewWhere_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, BigQueryParserRULE_where_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.Match(BigQueryParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(344)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_statementContext is an interface to support dynamic dispatch.
type IGroup_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroup_statementContext differentiates from other interfaces.
	IsGroup_statementContext()
}

type Group_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_statementContext() *Group_statementContext {
	var p = new(Group_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_group_statement
	return p
}

func InitEmptyGroup_statementContext(p *Group_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_group_statement
}

func (*Group_statementContext) IsGroup_statementContext() {}

func NewGroup_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_statementContext {
	var p = new(Group_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_group_statement

	return p
}

func (s *Group_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_statementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGROUP, 0)
}

func (s *Group_statementContext) BY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBY, 0)
}

func (s *Group_statementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(BigQueryParserROLLUP, 0)
}

func (s *Group_statementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Group_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Group_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Group_statementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Group_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Group_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Group_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterGroup_statement(s)
	}
}

func (s *Group_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitGroup_statement(s)
	}
}

func (s *Group_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitGroup_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Group_statement() (localctx IGroup_statementContext) {
	localctx = NewGroup_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, BigQueryParserRULE_group_statement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(BigQueryParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(347)
		p.Match(BigQueryParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(348)
			p.expr(0)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(349)
					p.Match(BigQueryParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(350)
					p.expr(0)
				}

			}
			p.SetState(355)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(356)
			p.Match(BigQueryParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(358)
			p.expr(0)
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == BigQueryParserCOMMA {
			{
				p.SetState(359)
				p.Match(BigQueryParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(360)
				p.expr(0)
			}

			p.SetState(365)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(366)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHaving_statementContext is an interface to support dynamic dispatch.
type IHaving_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsHaving_statementContext differentiates from other interfaces.
	IsHaving_statementContext()
}

type Having_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_statementContext() *Having_statementContext {
	var p = new(Having_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_having_statement
	return p
}

func InitEmptyHaving_statementContext(p *Having_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_having_statement
}

func (*Having_statementContext) IsHaving_statementContext() {}

func NewHaving_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_statementContext {
	var p = new(Having_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_having_statement

	return p
}

func (s *Having_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_statementContext) HAVING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserHAVING, 0)
}

func (s *Having_statementContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *Having_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterHaving_statement(s)
	}
}

func (s *Having_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitHaving_statement(s)
	}
}

func (s *Having_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitHaving_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Having_statement() (localctx IHaving_statementContext) {
	localctx = NewHaving_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, BigQueryParserRULE_having_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.Match(BigQueryParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(371)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_statementContext is an interface to support dynamic dispatch.
type IWindow_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Window_name() IWindow_nameContext
	AS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Window_definition() IWindow_definitionContext
	RR_BRACKET() antlr.TerminalNode

	// IsWindow_statementContext differentiates from other interfaces.
	IsWindow_statementContext()
}

type Window_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_statementContext() *Window_statementContext {
	var p = new(Window_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_statement
	return p
}

func InitEmptyWindow_statementContext(p *Window_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_statement
}

func (*Window_statementContext) IsWindow_statementContext() {}

func NewWindow_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_statementContext {
	var p = new(Window_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_window_statement

	return p
}

func (s *Window_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_statementContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWINDOW, 0)
}

func (s *Window_statementContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Window_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, 0)
}

func (s *Window_statementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Window_statementContext) Window_definition() IWindow_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definitionContext)
}

func (s *Window_statementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Window_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterWindow_statement(s)
	}
}

func (s *Window_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitWindow_statement(s)
	}
}

func (s *Window_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitWindow_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Window_statement() (localctx IWindow_statementContext) {
	localctx = NewWindow_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, BigQueryParserRULE_window_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(BigQueryParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Window_name()
	}
	{
		p.SetState(375)
		p.Match(BigQueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(376)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(377)
		p.Window_definition()
	}
	{
		p.SetState(378)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_clauseContext is an interface to support dynamic dispatch.
type IOrder_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllASC() []antlr.TerminalNode
	ASC(i int) antlr.TerminalNode
	AllDESC() []antlr.TerminalNode
	DESC(i int) antlr.TerminalNode

	// IsOrder_clauseContext differentiates from other interfaces.
	IsOrder_clauseContext()
}

type Order_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_clauseContext() *Order_clauseContext {
	var p = new(Order_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_order_clause
	return p
}

func InitEmptyOrder_clauseContext(p *Order_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_order_clause
}

func (*Order_clauseContext) IsOrder_clauseContext() {}

func NewOrder_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_clauseContext {
	var p = new(Order_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_order_clause

	return p
}

func (s *Order_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserORDER, 0)
}

func (s *Order_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBY, 0)
}

func (s *Order_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Order_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Order_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Order_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Order_clauseContext) AllASC() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserASC)
}

func (s *Order_clauseContext) ASC(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserASC, i)
}

func (s *Order_clauseContext) AllDESC() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserDESC)
}

func (s *Order_clauseContext) DESC(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserDESC, i)
}

func (s *Order_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterOrder_clause(s)
	}
}

func (s *Order_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitOrder_clause(s)
	}
}

func (s *Order_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitOrder_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Order_clause() (localctx IOrder_clauseContext) {
	localctx = NewOrder_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, BigQueryParserRULE_order_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(BigQueryParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)
		p.Match(BigQueryParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(382)
		p.expr(0)
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(383)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BigQueryParserASC || _la == BigQueryParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(386)
				p.Match(BigQueryParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(387)
				p.expr(0)
			}
			p.SetState(389)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(388)
					_la = p.GetTokenStream().LA(1)

					if !(_la == BigQueryParserASC || _la == BigQueryParserDESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_clauseContext is an interface to support dynamic dispatch.
type ILimit_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Count() ICountContext
	OFFSET() antlr.TerminalNode
	Skip_rows() ISkip_rowsContext

	// IsLimit_clauseContext differentiates from other interfaces.
	IsLimit_clauseContext()
}

type Limit_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_clauseContext() *Limit_clauseContext {
	var p = new(Limit_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_limit_clause
	return p
}

func InitEmptyLimit_clauseContext(p *Limit_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_limit_clause
}

func (*Limit_clauseContext) IsLimit_clauseContext() {}

func NewLimit_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_clauseContext {
	var p = new(Limit_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_limit_clause

	return p
}

func (s *Limit_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_clauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLIMIT, 0)
}

func (s *Limit_clauseContext) Count() ICountContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountContext)
}

func (s *Limit_clauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOFFSET, 0)
}

func (s *Limit_clauseContext) Skip_rows() ISkip_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkip_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkip_rowsContext)
}

func (s *Limit_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterLimit_clause(s)
	}
}

func (s *Limit_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitLimit_clause(s)
	}
}

func (s *Limit_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitLimit_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Limit_clause() (localctx ILimit_clauseContext) {
	localctx = NewLimit_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, BigQueryParserRULE_limit_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(BigQueryParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Count()
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(398)
			p.Match(BigQueryParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(399)
			p.Skip_rows()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_unary_operator
	return p
}

func InitEmptyUnary_operatorContext(p *Unary_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_unary_operator
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserMINUS, 0)
}

func (s *Unary_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTILDE, 0)
}

func (s *Unary_operatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNOT, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (s *Unary_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitUnary_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, BigQueryParserRULE_unary_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BigQueryParserNOT || _la == BigQueryParserMINUS || _la == BigQueryParserTILDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	String_() IStringContext
	Array_name() IArray_nameContext
	LSB() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	RR_BRACKET() antlr.TerminalNode
	RSB() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ORDINAL() antlr.TerminalNode
	SAFE_OFFSET() antlr.TerminalNode
	SAFE_ORDINAL() antlr.TerminalNode
	Unary_operator() IUnary_operatorContext
	IS() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	NOT() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	Function_name() IFunction_nameContext
	STAR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Cast_expr() ICast_exprContext
	Column_expr() IColumn_exprContext
	Keyword() IKeywordContext
	DIVIDE() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	DOUBLE_LT() antlr.TerminalNode
	DOUBLE_GT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	CARET() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	EQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	NE() antlr.TerminalNode
	LTGT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode
	S_NULL() antlr.TerminalNode
	IN() antlr.TerminalNode
	Query_statement() IQuery_statementContext
	UNNEST() antlr.TerminalNode
	Array_expr() IArray_exprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ExprContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExprContext) Array_name() IArray_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_nameContext)
}

func (s *ExprContext) LSB() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLSB, 0)
}

func (s *ExprContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *ExprContext) RSB() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRSB, 0)
}

func (s *ExprContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOFFSET, 0)
}

func (s *ExprContext) ORDINAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserORDINAL, 0)
}

func (s *ExprContext) SAFE_OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSAFE_OFFSET, 0)
}

func (s *ExprContext) SAFE_ORDINAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSAFE_ORDINAL, 0)
}

func (s *ExprContext) Unary_operator() IUnary_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *ExprContext) IS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIS, 0)
}

func (s *ExprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTRUE, 0)
}

func (s *ExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNOT, 0)
}

func (s *ExprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFALSE, 0)
}

func (s *ExprContext) Function_name() IFunction_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *ExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSTAR, 0)
}

func (s *ExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *ExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *ExprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *ExprContext) Column_expr() IColumn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_exprContext)
}

func (s *ExprContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ExprContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDIVIDE, 0)
}

func (s *ExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserPLUS, 0)
}

func (s *ExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserMINUS, 0)
}

func (s *ExprContext) DOUBLE_LT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDOUBLE_LT, 0)
}

func (s *ExprContext) DOUBLE_GT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDOUBLE_GT, 0)
}

func (s *ExprContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBIT_AND, 0)
}

func (s *ExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCARET, 0)
}

func (s *ExprContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBIT_OR, 0)
}

func (s *ExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEQ, 0)
}

func (s *ExprContext) LT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLT, 0)
}

func (s *ExprContext) GT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGT, 0)
}

func (s *ExprContext) LE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLE, 0)
}

func (s *ExprContext) GE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGE, 0)
}

func (s *ExprContext) NE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNE, 0)
}

func (s *ExprContext) LTGT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLTGT, 0)
}

func (s *ExprContext) LIKE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLIKE, 0)
}

func (s *ExprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBETWEEN, 0)
}

func (s *ExprContext) AND() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAND, 0)
}

func (s *ExprContext) OR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOR, 0)
}

func (s *ExprContext) S_NULL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserS_NULL, 0)
}

func (s *ExprContext) IN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIN, 0)
}

func (s *ExprContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *ExprContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNNEST, 0)
}

func (s *ExprContext) Array_expr() IArray_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_exprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *BigQueryParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, BigQueryParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(405)
			p.Number()
		}

	case 2:
		{
			p.SetState(406)
			p.String_()
		}

	case 3:
		{
			p.SetState(407)
			p.Array_name()
		}
		{
			p.SetState(408)
			p.Match(BigQueryParserLSB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&393233) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(410)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)
			p.expr(0)
		}
		{
			p.SetState(412)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(413)
			p.Match(BigQueryParserRSB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(415)
			p.Unary_operator()
		}
		{
			p.SetState(416)
			p.expr(20)
		}

	case 5:
		{
			p.SetState(418)
			p.Match(BigQueryParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserNOT {
			{
				p.SetState(419)
				p.Match(BigQueryParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(422)
			p.Match(BigQueryParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(423)
			p.Match(BigQueryParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserNOT {
			{
				p.SetState(424)
				p.Match(BigQueryParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(427)
			p.Match(BigQueryParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		{
			p.SetState(428)
			p.Function_name()
		}
		{
			p.SetState(429)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case BigQueryParserQUOTE, BigQueryParserDQOUTE, BigQueryParserALL, BigQueryParserAND, BigQueryParserANY, BigQueryParserARRAY, BigQueryParserAS, BigQueryParserASC, BigQueryParserASSERT_ROWS_MODIFIED, BigQueryParserAT, BigQueryParserBETWEEN, BigQueryParserBY, BigQueryParserCASE, BigQueryParserCAST, BigQueryParserCOLLATE, BigQueryParserCONTAINS, BigQueryParserCREATE, BigQueryParserCROSS, BigQueryParserCUBE, BigQueryParserCURRENT, BigQueryParserDEFAULT, BigQueryParserDEFINE, BigQueryParserDESC, BigQueryParserDISTINCT, BigQueryParserELSE, BigQueryParserEND, BigQueryParserENUM, BigQueryParserESCAPE, BigQueryParserEXCEPT, BigQueryParserEXCLUDE, BigQueryParserEXISTS, BigQueryParserEXTRACT, BigQueryParserFALSE, BigQueryParserFETCH, BigQueryParserFOLLOWING, BigQueryParserFOR, BigQueryParserFROM, BigQueryParserFULL, BigQueryParserGROUP, BigQueryParserGROUPING, BigQueryParserGROUPS, BigQueryParserHASH, BigQueryParserHAVING, BigQueryParserIF, BigQueryParserIGNORE, BigQueryParserIN, BigQueryParserINNER, BigQueryParserINTERSECT, BigQueryParserINTERVAL, BigQueryParserINTO, BigQueryParserIS, BigQueryParserJOIN, BigQueryParserLATERAL, BigQueryParserLEFT, BigQueryParserLIKE, BigQueryParserLIMIT, BigQueryParserLOOKUP, BigQueryParserMERGE, BigQueryParserNATURAL, BigQueryParserNEW, BigQueryParserNO, BigQueryParserNOT, BigQueryParserS_NULL, BigQueryParserNULLS, BigQueryParserOF, BigQueryParserOFFSET, BigQueryParserON, BigQueryParserOR, BigQueryParserORDER, BigQueryParserORDINAL, BigQueryParserOUTER, BigQueryParserOVER, BigQueryParserPARTITION, BigQueryParserPRECEDING, BigQueryParserPROTO, BigQueryParserRANGE, BigQueryParserRECURSIVE, BigQueryParserREPLACE, BigQueryParserRESPECT, BigQueryParserRIGHT, BigQueryParserROLLUP, BigQueryParserROWS, BigQueryParserSAFE_OFFSET, BigQueryParserSAFE_ORDINAL, BigQueryParserSELECT, BigQueryParserSET, BigQueryParserSOME, BigQueryParserSSTRUCT, BigQueryParserSYSTEM, BigQueryParserTABLESAMPLE, BigQueryParserTHEN, BigQueryParserTIME, BigQueryParserTO, BigQueryParserTREAT, BigQueryParserTRUE, BigQueryParserUNBOUNDED, BigQueryParserUNION, BigQueryParserUNNEST, BigQueryParserUSING, BigQueryParserWHEN, BigQueryParserWHERE, BigQueryParserWINDOW, BigQueryParserWITH, BigQueryParserWITHIN, BigQueryParserINT, BigQueryParserFLOAT, BigQueryParserQUOTED_STRING, BigQueryParserTRIPLE_QUOTED_STRING, BigQueryParserRAW_STRING, BigQueryParserBYTE_STRING, BigQueryParserRAW_BYTE_STRING, BigQueryParserID, BigQueryParserBACKTICK, BigQueryParserLR_BRACKET, BigQueryParserLSB, BigQueryParserMINUS, BigQueryParserTILDE:
			{
				p.SetState(430)
				p.expr(0)
			}
			p.SetState(435)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == BigQueryParserCOMMA {
				{
					p.SetState(431)
					p.Match(BigQueryParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(432)
					p.expr(0)
				}

				p.SetState(437)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case BigQueryParserSTAR:
			{
				p.SetState(438)
				p.Match(BigQueryParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(441)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		{
			p.SetState(443)
			p.Cast_expr()
		}

	case 9:
		{
			p.SetState(444)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.expr(0)
		}
		{
			p.SetState(446)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(448)
			p.Match(BigQueryParserLSB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(449)
			p.expr(0)
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == BigQueryParserCOMMA {
			{
				p.SetState(450)
				p.Match(BigQueryParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(451)
				p.expr(0)
			}

			p.SetState(456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(457)
			p.Match(BigQueryParserRSB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		{
			p.SetState(459)
			p.Column_expr()
		}

	case 12:
		{
			p.SetState(460)
			p.Keyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(463)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(464)
					_la = p.GetTokenStream().LA(1)

					if !(_la == BigQueryParserSTAR || _la == BigQueryParserDIVIDE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(465)
					p.expr(20)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(466)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(467)
					_la = p.GetTokenStream().LA(1)

					if !(_la == BigQueryParserPLUS || _la == BigQueryParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(468)
					p.expr(19)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(469)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(470)
					_la = p.GetTokenStream().LA(1)

					if !(_la == BigQueryParserDOUBLE_LT || _la == BigQueryParserDOUBLE_GT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(471)
					p.expr(18)
				}

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(472)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(473)
					p.Match(BigQueryParserBIT_AND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(474)
					p.expr(17)
				}

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(475)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(476)
					p.Match(BigQueryParserCARET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(477)
					p.expr(16)
				}

			case 6:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(478)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(479)
					p.Match(BigQueryParserBIT_OR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(480)
					p.expr(15)
				}

			case 7:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(481)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				p.SetState(501)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(482)
						p.Match(BigQueryParserEQ)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(483)
						p.Match(BigQueryParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(484)
						p.Match(BigQueryParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 4:
					{
						p.SetState(485)
						p.Match(BigQueryParserLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 5:
					{
						p.SetState(486)
						p.Match(BigQueryParserGE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 6:
					{
						p.SetState(487)
						p.Match(BigQueryParserNE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 7:
					{
						p.SetState(488)
						p.Match(BigQueryParserLTGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 8:
					p.SetState(490)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == BigQueryParserNOT {
						{
							p.SetState(489)
							p.Match(BigQueryParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(492)
						p.Match(BigQueryParserLIKE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 9:
					p.SetState(494)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == BigQueryParserNOT {
						{
							p.SetState(493)
							p.Match(BigQueryParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(496)
						p.Match(BigQueryParserBETWEEN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(497)
						p.expr(0)
					}
					{
						p.SetState(498)
						p.Match(BigQueryParserAND)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(499)
						p.expr(0)
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(503)
					p.expr(14)
				}

			case 8:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(504)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(505)
					p.Match(BigQueryParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(506)
					p.expr(9)
				}

			case 9:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(507)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(508)
					p.Match(BigQueryParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(509)
					p.expr(8)
				}

			case 10:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(510)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(511)
					p.Match(BigQueryParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(513)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == BigQueryParserNOT {
					{
						p.SetState(512)
						p.Match(BigQueryParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(515)
					p.Match(BigQueryParserS_NULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 11:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, BigQueryParserRULE_expr)
				p.SetState(516)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				p.SetState(518)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == BigQueryParserNOT {
					{
						p.SetState(517)
						p.Match(BigQueryParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(520)
					p.Match(BigQueryParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(538)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(521)
						p.Match(BigQueryParserLR_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(522)
						p.expr(0)
					}
					p.SetState(527)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					for _la == BigQueryParserCOMMA {
						{
							p.SetState(523)
							p.Match(BigQueryParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(524)
							p.expr(0)
						}

						p.SetState(529)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)
					}
					{
						p.SetState(530)
						p.Match(BigQueryParserRR_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(532)
						p.Query_statement()
					}

				case 3:
					{
						p.SetState(533)
						p.Match(BigQueryParserUNNEST)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(534)
						p.Match(BigQueryParserLR_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(535)
						p.Array_expr()
					}
					{
						p.SetState(536)
						p.Match(BigQueryParserRR_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICast_exprContext is an interface to support dynamic dispatch.
type ICast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext
	RR_BRACKET() antlr.TerminalNode

	// IsCast_exprContext differentiates from other interfaces.
	IsCast_exprContext()
}

type Cast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_exprContext() *Cast_exprContext {
	var p = new(Cast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_cast_expr
	return p
}

func InitEmptyCast_exprContext(p *Cast_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_cast_expr
}

func (*Cast_exprContext) IsCast_exprContext() {}

func NewCast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_exprContext {
	var p = new(Cast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_cast_expr

	return p
}

func (s *Cast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_exprContext) CAST() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCAST, 0)
}

func (s *Cast_exprContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Cast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Cast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, 0)
}

func (s *Cast_exprContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Cast_exprContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Cast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterCast_expr(s)
	}
}

func (s *Cast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitCast_expr(s)
	}
}

func (s *Cast_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitCast_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Cast_expr() (localctx ICast_exprContext) {
	localctx = NewCast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, BigQueryParserRULE_cast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(BigQueryParserCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(546)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(547)
		p.expr(0)
	}
	{
		p.SetState(548)
		p.Match(BigQueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(549)
		p.Datatype_name()
	}
	{
		p.SetState(550)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_exprContext is an interface to support dynamic dispatch.
type IColumn_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBACKTICK() []antlr.TerminalNode
	BACKTICK(i int) antlr.TerminalNode
	Column_expr() IColumn_exprContext
	Column_name() IColumn_nameContext
	Table_name() ITable_nameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Dataset_name() IDataset_nameContext
	Project_name() IProject_nameContext

	// IsColumn_exprContext differentiates from other interfaces.
	IsColumn_exprContext()
}

type Column_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_exprContext() *Column_exprContext {
	var p = new(Column_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_column_expr
	return p
}

func InitEmptyColumn_exprContext(p *Column_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_column_expr
}

func (*Column_exprContext) IsColumn_exprContext() {}

func NewColumn_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_exprContext {
	var p = new(Column_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_column_expr

	return p
}

func (s *Column_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_exprContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserBACKTICK)
}

func (s *Column_exprContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserBACKTICK, i)
}

func (s *Column_exprContext) Column_expr() IColumn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_exprContext)
}

func (s *Column_exprContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_exprContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Column_exprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserDOT)
}

func (s *Column_exprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserDOT, i)
}

func (s *Column_exprContext) Dataset_name() IDataset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataset_nameContext)
}

func (s *Column_exprContext) Project_name() IProject_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProject_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProject_nameContext)
}

func (s *Column_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterColumn_expr(s)
	}
}

func (s *Column_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitColumn_expr(s)
	}
}

func (s *Column_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitColumn_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Column_expr() (localctx IColumn_exprContext) {
	localctx = NewColumn_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, BigQueryParserRULE_column_expr)
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Column_expr()
		}
		{
			p.SetState(554)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			p.SetState(564)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
				p.SetState(559)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(556)
						p.Project_name()
					}
					{
						p.SetState(557)
						p.Match(BigQueryParserDOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(561)
					p.Dataset_name()
				}
				{
					p.SetState(562)
					p.Match(BigQueryParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(566)
				p.Table_name()
			}
			{
				p.SetState(567)
				p.Match(BigQueryParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(571)
			p.Column_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcept_statementContext is an interface to support dynamic dispatch.
type IExcept_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExcept_statementContext differentiates from other interfaces.
	IsExcept_statementContext()
}

type Except_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_statementContext() *Except_statementContext {
	var p = new(Except_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_except_statement
	return p
}

func InitEmptyExcept_statementContext(p *Except_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_except_statement
}

func (*Except_statementContext) IsExcept_statementContext() {}

func NewExcept_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_statementContext {
	var p = new(Except_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_except_statement

	return p
}

func (s *Except_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_statementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXCEPT, 0)
}

func (s *Except_statementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Except_statementContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Except_statementContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Except_statementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Except_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Except_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Except_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterExcept_statement(s)
	}
}

func (s *Except_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitExcept_statement(s)
	}
}

func (s *Except_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitExcept_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Except_statement() (localctx IExcept_statementContext) {
	localctx = NewExcept_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, BigQueryParserRULE_except_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(BigQueryParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(576)
		p.Column_name()
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BigQueryParserCOMMA {
		{
			p.SetState(577)
			p.Match(BigQueryParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)
			p.Column_name()
		}

		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(584)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplace_statementContext is an interface to support dynamic dispatch.
type IReplace_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	RR_BRACKET() antlr.TerminalNode
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode

	// IsReplace_statementContext differentiates from other interfaces.
	IsReplace_statementContext()
}

type Replace_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_statementContext() *Replace_statementContext {
	var p = new(Replace_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_replace_statement
	return p
}

func InitEmptyReplace_statementContext(p *Replace_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_replace_statement
}

func (*Replace_statementContext) IsReplace_statementContext() {}

func NewReplace_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_statementContext {
	var p = new(Replace_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_replace_statement

	return p
}

func (s *Replace_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_statementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserREPLACE, 0)
}

func (s *Replace_statementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Replace_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Replace_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Replace_statementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Replace_statementContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *Replace_statementContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *Replace_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Replace_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Replace_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserAS)
}

func (s *Replace_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, i)
}

func (s *Replace_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replace_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterReplace_statement(s)
	}
}

func (s *Replace_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitReplace_statement(s)
	}
}

func (s *Replace_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitReplace_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Replace_statement() (localctx IReplace_statementContext) {
	localctx = NewReplace_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, BigQueryParserRULE_replace_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(BigQueryParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(587)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(588)
		p.expr(0)
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262) != 0) || ((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&25) != 0) {
		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserAS {
			{
				p.SetState(589)
				p.Match(BigQueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(592)
			p.Alias_name()
		}

	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BigQueryParserCOMMA {
		{
			p.SetState(595)
			p.Match(BigQueryParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.expr(0)
		}

		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserAS {
			{
				p.SetState(597)
				p.Match(BigQueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(600)
			p.Alias_name()
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(607)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_typeContext is an interface to support dynamic dispatch.
type IJoin_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsJoin_typeContext differentiates from other interfaces.
	IsJoin_typeContext()
}

type Join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_typeContext() *Join_typeContext {
	var p = new(Join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_join_type
	return p
}

func InitEmptyJoin_typeContext(p *Join_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_join_type
}

func (*Join_typeContext) IsJoin_typeContext() {}

func NewJoin_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_typeContext {
	var p = new(Join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_join_type

	return p
}

func (s *Join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_typeContext) INNER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINNER, 0)
}

func (s *Join_typeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCROSS, 0)
}

func (s *Join_typeContext) FULL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFULL, 0)
}

func (s *Join_typeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOUTER, 0)
}

func (s *Join_typeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLEFT, 0)
}

func (s *Join_typeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRIGHT, 0)
}

func (s *Join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterJoin_type(s)
	}
}

func (s *Join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitJoin_type(s)
	}
}

func (s *Join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitJoin_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Join_type() (localctx IJoin_typeContext) {
	localctx = NewJoin_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, BigQueryParserRULE_join_type)
	var _la int

	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserINNER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.Match(BigQueryParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserCROSS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(610)
			p.Match(BigQueryParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserFULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(611)
			p.Match(BigQueryParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserOUTER {
			{
				p.SetState(612)
				p.Match(BigQueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case BigQueryParserLEFT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(615)
			p.Match(BigQueryParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserOUTER {
			{
				p.SetState(616)
				p.Match(BigQueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case BigQueryParserRIGHT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(619)
			p.Match(BigQueryParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserOUTER {
			{
				p.SetState(620)
				p.Match(BigQueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOn_clauseContext is an interface to support dynamic dispatch.
type IOn_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsOn_clauseContext differentiates from other interfaces.
	IsOn_clauseContext()
}

type On_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_clauseContext() *On_clauseContext {
	var p = new(On_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_on_clause
	return p
}

func InitEmptyOn_clauseContext(p *On_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_on_clause
}

func (*On_clauseContext) IsOn_clauseContext() {}

func NewOn_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_clauseContext {
	var p = new(On_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_on_clause

	return p
}

func (s *On_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *On_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(BigQueryParserON, 0)
}

func (s *On_clauseContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *On_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *On_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterOn_clause(s)
	}
}

func (s *On_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitOn_clause(s)
	}
}

func (s *On_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitOn_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) On_clause() (localctx IOn_clauseContext) {
	localctx = NewOn_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, BigQueryParserRULE_on_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(BigQueryParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_opContext is an interface to support dynamic dispatch.
type ISet_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsSet_opContext differentiates from other interfaces.
	IsSet_opContext()
}

type Set_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_opContext() *Set_opContext {
	var p = new(Set_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_set_op
	return p
}

func InitEmptySet_opContext(p *Set_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_set_op
}

func (*Set_opContext) IsSet_opContext() {}

func NewSet_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_opContext {
	var p = new(Set_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_set_op

	return p
}

func (s *Set_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_opContext) UNION() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNION, 0)
}

func (s *Set_opContext) ALL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserALL, 0)
}

func (s *Set_opContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDISTINCT, 0)
}

func (s *Set_opContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINTERSECT, 0)
}

func (s *Set_opContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXCEPT, 0)
}

func (s *Set_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterSet_op(s)
	}
}

func (s *Set_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitSet_op(s)
	}
}

func (s *Set_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitSet_op(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Set_op() (localctx ISet_opContext) {
	localctx = NewSet_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, BigQueryParserRULE_set_op)
	var _la int

	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(628)
			p.Match(BigQueryParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == BigQueryParserALL || _la == BigQueryParserDISTINCT {
			{
				p.SetState(629)
				_la = p.GetTokenStream().LA(1)

				if !(_la == BigQueryParserALL || _la == BigQueryParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case BigQueryParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Match(BigQueryParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.Match(BigQueryParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(634)
			p.Match(BigQueryParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.Match(BigQueryParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllJoin_name() []IJoin_nameContext
	Join_name(i int) IJoin_nameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) USING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUSING, 0)
}

func (s *Using_clauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *Using_clauseContext) AllJoin_name() []IJoin_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_nameContext); ok {
			len++
		}
	}

	tst := make([]IJoin_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_nameContext); ok {
			tst[i] = t.(IJoin_nameContext)
			i++
		}
	}

	return tst
}

func (s *Using_clauseContext) Join_name(i int) IJoin_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_nameContext)
}

func (s *Using_clauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *Using_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *Using_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (s *Using_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitUsing_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, BigQueryParserRULE_using_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(BigQueryParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(639)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(640)
		p.Join_name()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BigQueryParserCOMMA {
		{
			p.SetState(641)
			p.Match(BigQueryParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(642)
			p.Join_name()
		}

		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(648)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_pathContext is an interface to support dynamic dispatch.
type IField_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsField_pathContext differentiates from other interfaces.
	IsField_pathContext()
}

type Field_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_pathContext() *Field_pathContext {
	var p = new(Field_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_field_path
	return p
}

func InitEmptyField_pathContext(p *Field_pathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_field_path
}

func (*Field_pathContext) IsField_pathContext() {}

func NewField_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_pathContext {
	var p = new(Field_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_field_path

	return p
}

func (s *Field_pathContext) GetParser() antlr.Parser { return s.parser }
func (s *Field_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterField_path(s)
	}
}

func (s *Field_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitField_path(s)
	}
}

func (s *Field_pathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitField_path(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Field_path() (localctx IField_pathContext) {
	localctx = NewField_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, BigQueryParserRULE_field_path)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISstructContext is an interface to support dynamic dispatch.
type ISstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSTRUCT() antlr.TerminalNode
	LT() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext
	GT() antlr.TerminalNode

	// IsSstructContext differentiates from other interfaces.
	IsSstructContext()
}

type SstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySstructContext() *SstructContext {
	var p = new(SstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_sstruct
	return p
}

func InitEmptySstructContext(p *SstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_sstruct
}

func (*SstructContext) IsSstructContext() {}

func NewSstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SstructContext {
	var p = new(SstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_sstruct

	return p
}

func (s *SstructContext) GetParser() antlr.Parser { return s.parser }

func (s *SstructContext) SSTRUCT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSSTRUCT, 0)
}

func (s *SstructContext) LT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLT, 0)
}

func (s *SstructContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *SstructContext) GT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGT, 0)
}

func (s *SstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterSstruct(s)
	}
}

func (s *SstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitSstruct(s)
	}
}

func (s *SstructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitSstruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Sstruct() (localctx ISstructContext) {
	localctx = NewSstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, BigQueryParserRULE_sstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(BigQueryParserSSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Match(BigQueryParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(654)
		p.Datatype_name()
	}
	{
		p.SetState(655)
		p.Match(BigQueryParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_exprContext is an interface to support dynamic dispatch.
type IArray_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext
	GT() antlr.TerminalNode

	// IsArray_exprContext differentiates from other interfaces.
	IsArray_exprContext()
}

type Array_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_exprContext() *Array_exprContext {
	var p = new(Array_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_expr
	return p
}

func InitEmptyArray_exprContext(p *Array_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_expr
}

func (*Array_exprContext) IsArray_exprContext() {}

func NewArray_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_exprContext {
	var p = new(Array_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_array_expr

	return p
}

func (s *Array_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_exprContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserARRAY, 0)
}

func (s *Array_exprContext) LT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLT, 0)
}

func (s *Array_exprContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Array_exprContext) GT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGT, 0)
}

func (s *Array_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterArray_expr(s)
	}
}

func (s *Array_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitArray_expr(s)
	}
}

func (s *Array_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitArray_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Array_expr() (localctx IArray_exprContext) {
	localctx = NewArray_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, BigQueryParserRULE_array_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(BigQueryParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Match(BigQueryParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(659)
		p.Datatype_name()
	}
	{
		p.SetState(660)
		p.Match(BigQueryParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_pathContext is an interface to support dynamic dispatch.
type IArray_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArray_pathContext differentiates from other interfaces.
	IsArray_pathContext()
}

type Array_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_pathContext() *Array_pathContext {
	var p = new(Array_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_path
	return p
}

func InitEmptyArray_pathContext(p *Array_pathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_path
}

func (*Array_pathContext) IsArray_pathContext() {}

func NewArray_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_pathContext {
	var p = new(Array_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_array_path

	return p
}

func (s *Array_pathContext) GetParser() antlr.Parser { return s.parser }
func (s *Array_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterArray_path(s)
	}
}

func (s *Array_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitArray_path(s)
	}
}

func (s *Array_pathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitArray_path(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Array_path() (localctx IArray_pathContext) {
	localctx = NewArray_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, BigQueryParserRULE_array_path)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expressionContext is an interface to support dynamic dispatch.
type IBool_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsBool_expressionContext differentiates from other interfaces.
	IsBool_expressionContext()
}

type Bool_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expressionContext() *Bool_expressionContext {
	var p = new(Bool_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_bool_expression
	return p
}

func InitEmptyBool_expressionContext(p *Bool_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_bool_expression
}

func (*Bool_expressionContext) IsBool_expressionContext() {}

func NewBool_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expressionContext {
	var p = new(Bool_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_bool_expression

	return p
}

func (s *Bool_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterBool_expression(s)
	}
}

func (s *Bool_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitBool_expression(s)
	}
}

func (s *Bool_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitBool_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Bool_expression() (localctx IBool_expressionContext) {
	localctx = NewBool_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, BigQueryParserRULE_bool_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_nameContext is an interface to support dynamic dispatch.
type IWindow_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindow_nameContext differentiates from other interfaces.
	IsWindow_nameContext()
}

type Window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_nameContext() *Window_nameContext {
	var p = new(Window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_name
	return p
}

func InitEmptyWindow_nameContext(p *Window_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_name
}

func (*Window_nameContext) IsWindow_nameContext() {}

func NewWindow_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_nameContext {
	var p = new(Window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_window_name

	return p
}

func (s *Window_nameContext) GetParser() antlr.Parser { return s.parser }
func (s *Window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterWindow_name(s)
	}
}

func (s *Window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitWindow_name(s)
	}
}

func (s *Window_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitWindow_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Window_name() (localctx IWindow_nameContext) {
	localctx = NewWindow_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, BigQueryParserRULE_window_name)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_definitionContext is an interface to support dynamic dispatch.
type IWindow_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindow_definitionContext differentiates from other interfaces.
	IsWindow_definitionContext()
}

type Window_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definitionContext() *Window_definitionContext {
	var p = new(Window_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_definition
	return p
}

func InitEmptyWindow_definitionContext(p *Window_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_window_definition
}

func (*Window_definitionContext) IsWindow_definitionContext() {}

func NewWindow_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definitionContext {
	var p = new(Window_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_window_definition

	return p
}

func (s *Window_definitionContext) GetParser() antlr.Parser { return s.parser }
func (s *Window_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterWindow_definition(s)
	}
}

func (s *Window_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitWindow_definition(s)
	}
}

func (s *Window_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitWindow_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Window_definition() (localctx IWindow_definitionContext) {
	localctx = NewWindow_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, BigQueryParserRULE_window_definition)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountContext is an interface to support dynamic dispatch.
type ICountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsCountContext differentiates from other interfaces.
	IsCountContext()
}

type CountContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountContext() *CountContext {
	var p = new(CountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_count
	return p
}

func InitEmptyCountContext(p *CountContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_count
}

func (*CountContext) IsCountContext() {}

func NewCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountContext {
	var p = new(CountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_count

	return p
}

func (s *CountContext) GetParser() antlr.Parser { return s.parser }

func (s *CountContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterCount(s)
	}
}

func (s *CountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitCount(s)
	}
}

func (s *CountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Count() (localctx ICountContext) {
	localctx = NewCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, BigQueryParserRULE_count)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkip_rowsContext is an interface to support dynamic dispatch.
type ISkip_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSkip_rowsContext differentiates from other interfaces.
	IsSkip_rowsContext()
}

type Skip_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkip_rowsContext() *Skip_rowsContext {
	var p = new(Skip_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_skip_rows
	return p
}

func InitEmptySkip_rowsContext(p *Skip_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_skip_rows
}

func (*Skip_rowsContext) IsSkip_rowsContext() {}

func NewSkip_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Skip_rowsContext {
	var p = new(Skip_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_skip_rows

	return p
}

func (s *Skip_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Skip_rowsContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Skip_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Skip_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Skip_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterSkip_rows(s)
	}
}

func (s *Skip_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitSkip_rows(s)
	}
}

func (s *Skip_rowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitSkip_rows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Skip_rows() (localctx ISkip_rowsContext) {
	localctx = NewSkip_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, BigQueryParserRULE_skip_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_statementContext is an interface to support dynamic dispatch.
type IWith_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCte_name() []ICte_nameContext
	Cte_name(i int) ICte_nameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllQuery_expr() []IQuery_exprContext
	Query_expr(i int) IQuery_exprContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_statementContext differentiates from other interfaces.
	IsWith_statementContext()
}

type With_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_statementContext() *With_statementContext {
	var p = new(With_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_with_statement
	return p
}

func InitEmptyWith_statementContext(p *With_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_with_statement
}

func (*With_statementContext) IsWith_statementContext() {}

func NewWith_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_statementContext {
	var p = new(With_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_with_statement

	return p
}

func (s *With_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *With_statementContext) WITH() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWITH, 0)
}

func (s *With_statementContext) AllCte_name() []ICte_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICte_nameContext); ok {
			len++
		}
	}

	tst := make([]ICte_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICte_nameContext); ok {
			tst[i] = t.(ICte_nameContext)
			i++
		}
	}

	return tst
}

func (s *With_statementContext) Cte_name(i int) ICte_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_nameContext)
}

func (s *With_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserAS)
}

func (s *With_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, i)
}

func (s *With_statementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserLR_BRACKET)
}

func (s *With_statementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, i)
}

func (s *With_statementContext) AllQuery_expr() []IQuery_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_exprContext); ok {
			len++
		}
	}

	tst := make([]IQuery_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_exprContext); ok {
			tst[i] = t.(IQuery_exprContext)
			i++
		}
	}

	return tst
}

func (s *With_statementContext) Query_expr(i int) IQuery_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *With_statementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserRR_BRACKET)
}

func (s *With_statementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, i)
}

func (s *With_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserCOMMA)
}

func (s *With_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOMMA, i)
}

func (s *With_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterWith_statement(s)
	}
}

func (s *With_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitWith_statement(s)
	}
}

func (s *With_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitWith_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) With_statement() (localctx IWith_statementContext) {
	localctx = NewWith_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, BigQueryParserRULE_with_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(BigQueryParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(675)
		p.Cte_name()
	}
	{
		p.SetState(676)
		p.Match(BigQueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(677)
		p.Match(BigQueryParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(678)
		p.query_expr(0)
	}
	{
		p.SetState(679)
		p.Match(BigQueryParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == BigQueryParserCOMMA {
		{
			p.SetState(680)
			p.Match(BigQueryParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(681)
			p.Cte_name()
		}
		{
			p.SetState(682)
			p.Match(BigQueryParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.query_expr(0)
		}
		{
			p.SetState(685)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	AllDQOUTE() []antlr.TerminalNode
	DQOUTE(i int) antlr.TerminalNode
	Name() INameContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllBACKTICK() []antlr.TerminalNode
	BACKTICK(i int) antlr.TerminalNode
	AllQUOTE() []antlr.TerminalNode
	QUOTE(i int) antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) ID() antlr.TerminalNode {
	return s.GetToken(BigQueryParserID, 0)
}

func (s *NameContext) AllDQOUTE() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserDQOUTE)
}

func (s *NameContext) DQOUTE(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserDQOUTE, i)
}

func (s *NameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *NameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLR_BRACKET, 0)
}

func (s *NameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRR_BRACKET, 0)
}

func (s *NameContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserBACKTICK)
}

func (s *NameContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserBACKTICK, i)
}

func (s *NameContext) AllQUOTE() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserQUOTE)
}

func (s *NameContext) QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserQUOTE, i)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, BigQueryParserRULE_name)
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(692)
			p.Match(BigQueryParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserDQOUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(693)
			p.Match(BigQueryParserDQOUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)
			p.Name()
		}
		{
			p.SetState(695)
			p.Match(BigQueryParserDQOUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(697)
			p.Match(BigQueryParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(698)
			p.Name()
		}
		{
			p.SetState(699)
			p.Match(BigQueryParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserBACKTICK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(701)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(702)
			p.Name()
		}
		{
			p.SetState(703)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case BigQueryParserQUOTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(705)
			p.Match(BigQueryParserQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)
			p.Name()
		}
		{
			p.SetState(707)
			p.Match(BigQueryParserQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlias_nameContext is an interface to support dynamic dispatch.
type IAlias_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsAlias_nameContext differentiates from other interfaces.
	IsAlias_nameContext()
}

type Alias_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_nameContext() *Alias_nameContext {
	var p = new(Alias_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_alias_name
	return p
}

func InitEmptyAlias_nameContext(p *Alias_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_alias_name
}

func (*Alias_nameContext) IsAlias_nameContext() {}

func NewAlias_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_nameContext {
	var p = new(Alias_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_alias_name

	return p
}

func (s *Alias_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Alias_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterAlias_name(s)
	}
}

func (s *Alias_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitAlias_name(s)
	}
}

func (s *Alias_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitAlias_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Alias_name() (localctx IAlias_nameContext) {
	localctx = NewAlias_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, BigQueryParserRULE_alias_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_nameContext is an interface to support dynamic dispatch.
type IArray_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsArray_nameContext differentiates from other interfaces.
	IsArray_nameContext()
}

type Array_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_nameContext() *Array_nameContext {
	var p = new(Array_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_name
	return p
}

func InitEmptyArray_nameContext(p *Array_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_array_name
}

func (*Array_nameContext) IsArray_nameContext() {}

func NewArray_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_nameContext {
	var p = new(Array_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_array_name

	return p
}

func (s *Array_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Array_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterArray_name(s)
	}
}

func (s *Array_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitArray_name(s)
	}
}

func (s *Array_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitArray_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Array_name() (localctx IArray_nameContext) {
	localctx = NewArray_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, BigQueryParserRULE_array_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (s *Column_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitColumn_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, BigQueryParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_nameContext is an interface to support dynamic dispatch.
type ICte_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsCte_nameContext differentiates from other interfaces.
	IsCte_nameContext()
}

type Cte_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_nameContext() *Cte_nameContext {
	var p = new(Cte_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_cte_name
	return p
}

func InitEmptyCte_nameContext(p *Cte_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_cte_name
}

func (*Cte_nameContext) IsCte_nameContext() {}

func NewCte_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_nameContext {
	var p = new(Cte_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_cte_name

	return p
}

func (s *Cte_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Cte_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterCte_name(s)
	}
}

func (s *Cte_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitCte_name(s)
	}
}

func (s *Cte_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitCte_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Cte_name() (localctx ICte_nameContext) {
	localctx = NewCte_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, BigQueryParserRULE_cte_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataset_nameContext is an interface to support dynamic dispatch.
type IDataset_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsDataset_nameContext differentiates from other interfaces.
	IsDataset_nameContext()
}

type Dataset_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataset_nameContext() *Dataset_nameContext {
	var p = new(Dataset_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_dataset_name
	return p
}

func InitEmptyDataset_nameContext(p *Dataset_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_dataset_name
}

func (*Dataset_nameContext) IsDataset_nameContext() {}

func NewDataset_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dataset_nameContext {
	var p = new(Dataset_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_dataset_name

	return p
}

func (s *Dataset_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dataset_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dataset_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dataset_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dataset_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterDataset_name(s)
	}
}

func (s *Dataset_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitDataset_name(s)
	}
}

func (s *Dataset_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitDataset_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Dataset_name() (localctx IDataset_nameContext) {
	localctx = NewDataset_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, BigQueryParserRULE_dataset_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatype_nameContext is an interface to support dynamic dispatch.
type IDatatype_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsDatatype_nameContext differentiates from other interfaces.
	IsDatatype_nameContext()
}

type Datatype_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_nameContext() *Datatype_nameContext {
	var p = new(Datatype_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_datatype_name
	return p
}

func InitEmptyDatatype_nameContext(p *Datatype_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_datatype_name
}

func (*Datatype_nameContext) IsDatatype_nameContext() {}

func NewDatatype_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_nameContext {
	var p = new(Datatype_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_datatype_name

	return p
}

func (s *Datatype_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Datatype_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterDatatype_name(s)
	}
}

func (s *Datatype_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitDatatype_name(s)
	}
}

func (s *Datatype_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitDatatype_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Datatype_name() (localctx IDatatype_nameContext) {
	localctx = NewDatatype_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, BigQueryParserRULE_datatype_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_function_name
	return p
}

func InitEmptyFunction_nameContext(p *Function_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_function_name
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (s *Function_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitFunction_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Function_name() (localctx IFunction_nameContext) {
	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, BigQueryParserRULE_function_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_nameContext is an interface to support dynamic dispatch.
type IJoin_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsJoin_nameContext differentiates from other interfaces.
	IsJoin_nameContext()
}

type Join_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_nameContext() *Join_nameContext {
	var p = new(Join_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_join_name
	return p
}

func InitEmptyJoin_nameContext(p *Join_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_join_name
}

func (*Join_nameContext) IsJoin_nameContext() {}

func NewJoin_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_nameContext {
	var p = new(Join_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_join_name

	return p
}

func (s *Join_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Join_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterJoin_name(s)
	}
}

func (s *Join_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitJoin_name(s)
	}
}

func (s *Join_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitJoin_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Join_name() (localctx IJoin_nameContext) {
	localctx = NewJoin_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, BigQueryParserRULE_join_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMember_nameContext is an interface to support dynamic dispatch.
type IMember_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsMember_nameContext differentiates from other interfaces.
	IsMember_nameContext()
}

type Member_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_nameContext() *Member_nameContext {
	var p = new(Member_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_member_name
	return p
}

func InitEmptyMember_nameContext(p *Member_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_member_name
}

func (*Member_nameContext) IsMember_nameContext() {}

func NewMember_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_nameContext {
	var p = new(Member_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_member_name

	return p
}

func (s *Member_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Member_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterMember_name(s)
	}
}

func (s *Member_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitMember_name(s)
	}
}

func (s *Member_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitMember_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Member_name() (localctx IMember_nameContext) {
	localctx = NewMember_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, BigQueryParserRULE_member_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProject_nameContext is an interface to support dynamic dispatch.
type IProject_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsProject_nameContext differentiates from other interfaces.
	IsProject_nameContext()
}

type Project_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProject_nameContext() *Project_nameContext {
	var p = new(Project_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_project_name
	return p
}

func InitEmptyProject_nameContext(p *Project_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_project_name
}

func (*Project_nameContext) IsProject_nameContext() {}

func NewProject_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Project_nameContext {
	var p = new(Project_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_project_name

	return p
}

func (s *Project_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Project_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Project_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Project_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Project_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterProject_name(s)
	}
}

func (s *Project_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitProject_name(s)
	}
}

func (s *Project_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitProject_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Project_name() (localctx IProject_nameContext) {
	localctx = NewProject_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, BigQueryParserRULE_project_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_nameContext is an interface to support dynamic dispatch.
type IStruct_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsStruct_nameContext differentiates from other interfaces.
	IsStruct_nameContext()
}

type Struct_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_nameContext() *Struct_nameContext {
	var p = new(Struct_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_struct_name
	return p
}

func InitEmptyStruct_nameContext(p *Struct_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_struct_name
}

func (*Struct_nameContext) IsStruct_nameContext() {}

func NewStruct_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_nameContext {
	var p = new(Struct_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_struct_name

	return p
}

func (s *Struct_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Struct_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterStruct_name(s)
	}
}

func (s *Struct_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitStruct_name(s)
	}
}

func (s *Struct_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitStruct_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Struct_name() (localctx IStruct_nameContext) {
	localctx = NewStruct_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, BigQueryParserRULE_struct_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitTable_name(s)
	}
}

func (s *Table_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitTable_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, BigQueryParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_exprContext is an interface to support dynamic dispatch.
type ITable_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	Dataset_name() IDataset_nameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Project_name() IProject_nameContext
	AllBACKTICK() []antlr.TerminalNode
	BACKTICK(i int) antlr.TerminalNode
	Table_expr() ITable_exprContext

	// IsTable_exprContext differentiates from other interfaces.
	IsTable_exprContext()
}

type Table_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_exprContext() *Table_exprContext {
	var p = new(Table_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_table_expr
	return p
}

func InitEmptyTable_exprContext(p *Table_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_table_expr
}

func (*Table_exprContext) IsTable_exprContext() {}

func NewTable_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_exprContext {
	var p = new(Table_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_table_expr

	return p
}

func (s *Table_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_exprContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Table_exprContext) Dataset_name() IDataset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataset_nameContext)
}

func (s *Table_exprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserDOT)
}

func (s *Table_exprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserDOT, i)
}

func (s *Table_exprContext) Project_name() IProject_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProject_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProject_nameContext)
}

func (s *Table_exprContext) AllBACKTICK() []antlr.TerminalNode {
	return s.GetTokens(BigQueryParserBACKTICK)
}

func (s *Table_exprContext) BACKTICK(i int) antlr.TerminalNode {
	return s.GetToken(BigQueryParserBACKTICK, i)
}

func (s *Table_exprContext) Table_expr() ITable_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_exprContext)
}

func (s *Table_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterTable_expr(s)
	}
}

func (s *Table_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitTable_expr(s)
	}
}

func (s *Table_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitTable_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Table_expr() (localctx ITable_exprContext) {
	localctx = NewTable_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, BigQueryParserRULE_table_expr)
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(743)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			p.SetState(738)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(735)
					p.Project_name()
				}
				{
					p.SetState(736)
					p.Match(BigQueryParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(740)
				p.Dataset_name()
			}
			{
				p.SetState(741)
				p.Match(BigQueryParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(745)
			p.Table_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(746)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.Table_expr()
		}
		{
			p.SetState(748)
			p.Match(BigQueryParserBACKTICK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer_type() IInteger_typeContext
	Float_type() IFloat_typeContext

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer_type() IInteger_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *NumberContext) Float_type() IFloat_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_typeContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, BigQueryParserRULE_number)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.Integer_type()
		}

	case BigQueryParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Float_type()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_integer_type
	return p
}

func InitEmptyInteger_typeContext(p *Integer_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_integer_type
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) INT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINT, 0)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (s *Integer_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitInteger_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Integer_type() (localctx IInteger_typeContext) {
	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, BigQueryParserRULE_integer_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Match(BigQueryParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloat_typeContext is an interface to support dynamic dispatch.
type IFloat_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode

	// IsFloat_typeContext differentiates from other interfaces.
	IsFloat_typeContext()
}

type Float_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_typeContext() *Float_typeContext {
	var p = new(Float_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_float_type
	return p
}

func InitEmptyFloat_typeContext(p *Float_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_float_type
}

func (*Float_typeContext) IsFloat_typeContext() {}

func NewFloat_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_typeContext {
	var p = new(Float_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_float_type

	return p
}

func (s *Float_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_typeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFLOAT, 0)
}

func (s *Float_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterFloat_type(s)
	}
}

func (s *Float_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitFloat_type(s)
	}
}

func (s *Float_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitFloat_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Float_type() (localctx IFloat_typeContext) {
	localctx = NewFloat_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, BigQueryParserRULE_float_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(BigQueryParserFLOAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Quoted_string() IQuoted_stringContext
	Triple_quoted_string() ITriple_quoted_stringContext
	Raw_string() IRaw_stringContext
	Byte_string() IByte_stringContext
	Raw_byte_string() IRaw_byte_stringContext
	Special_string() ISpecial_stringContext

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) Quoted_string() IQuoted_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuoted_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *StringContext) Triple_quoted_string() ITriple_quoted_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriple_quoted_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriple_quoted_stringContext)
}

func (s *StringContext) Raw_string() IRaw_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaw_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaw_stringContext)
}

func (s *StringContext) Byte_string() IByte_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IByte_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IByte_stringContext)
}

func (s *StringContext) Raw_byte_string() IRaw_byte_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaw_byte_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaw_byte_stringContext)
}

func (s *StringContext) Special_string() ISpecial_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecial_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecial_stringContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, BigQueryParserRULE_string)
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case BigQueryParserQUOTED_STRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(760)
			p.Quoted_string()
		}

	case BigQueryParserTRIPLE_QUOTED_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.Triple_quoted_string()
		}

	case BigQueryParserRAW_STRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(762)
			p.Raw_string()
		}

	case BigQueryParserBYTE_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(763)
			p.Byte_string()
		}

	case BigQueryParserRAW_BYTE_STRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(764)
			p.Raw_byte_string()
		}

	case BigQueryParserQUOTE, BigQueryParserDQOUTE, BigQueryParserID, BigQueryParserBACKTICK, BigQueryParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(765)
			p.Special_string()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTED_STRING() antlr.TerminalNode

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_quoted_string
	return p
}

func InitEmptyQuoted_stringContext(p *Quoted_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_quoted_string
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserQUOTED_STRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (s *Quoted_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitQuoted_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, BigQueryParserRULE_quoted_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(BigQueryParserQUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriple_quoted_stringContext is an interface to support dynamic dispatch.
type ITriple_quoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_QUOTED_STRING() antlr.TerminalNode

	// IsTriple_quoted_stringContext differentiates from other interfaces.
	IsTriple_quoted_stringContext()
}

type Triple_quoted_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriple_quoted_stringContext() *Triple_quoted_stringContext {
	var p = new(Triple_quoted_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_triple_quoted_string
	return p
}

func InitEmptyTriple_quoted_stringContext(p *Triple_quoted_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_triple_quoted_string
}

func (*Triple_quoted_stringContext) IsTriple_quoted_stringContext() {}

func NewTriple_quoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Triple_quoted_stringContext {
	var p = new(Triple_quoted_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_triple_quoted_string

	return p
}

func (s *Triple_quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Triple_quoted_stringContext) TRIPLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTRIPLE_QUOTED_STRING, 0)
}

func (s *Triple_quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Triple_quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Triple_quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterTriple_quoted_string(s)
	}
}

func (s *Triple_quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitTriple_quoted_string(s)
	}
}

func (s *Triple_quoted_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitTriple_quoted_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Triple_quoted_string() (localctx ITriple_quoted_stringContext) {
	localctx = NewTriple_quoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, BigQueryParserRULE_triple_quoted_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(BigQueryParserTRIPLE_QUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaw_stringContext is an interface to support dynamic dispatch.
type IRaw_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_STRING() antlr.TerminalNode

	// IsRaw_stringContext differentiates from other interfaces.
	IsRaw_stringContext()
}

type Raw_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaw_stringContext() *Raw_stringContext {
	var p = new(Raw_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_raw_string
	return p
}

func InitEmptyRaw_stringContext(p *Raw_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_raw_string
}

func (*Raw_stringContext) IsRaw_stringContext() {}

func NewRaw_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raw_stringContext {
	var p = new(Raw_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_raw_string

	return p
}

func (s *Raw_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Raw_stringContext) RAW_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRAW_STRING, 0)
}

func (s *Raw_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raw_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raw_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterRaw_string(s)
	}
}

func (s *Raw_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitRaw_string(s)
	}
}

func (s *Raw_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitRaw_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Raw_string() (localctx IRaw_stringContext) {
	localctx = NewRaw_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, BigQueryParserRULE_raw_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(BigQueryParserRAW_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IByte_stringContext is an interface to support dynamic dispatch.
type IByte_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTE_STRING() antlr.TerminalNode

	// IsByte_stringContext differentiates from other interfaces.
	IsByte_stringContext()
}

type Byte_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyByte_stringContext() *Byte_stringContext {
	var p = new(Byte_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_byte_string
	return p
}

func InitEmptyByte_stringContext(p *Byte_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_byte_string
}

func (*Byte_stringContext) IsByte_stringContext() {}

func NewByte_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Byte_stringContext {
	var p = new(Byte_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_byte_string

	return p
}

func (s *Byte_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Byte_stringContext) BYTE_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBYTE_STRING, 0)
}

func (s *Byte_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Byte_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Byte_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterByte_string(s)
	}
}

func (s *Byte_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitByte_string(s)
	}
}

func (s *Byte_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitByte_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Byte_string() (localctx IByte_stringContext) {
	localctx = NewByte_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, BigQueryParserRULE_byte_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(BigQueryParserBYTE_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaw_byte_stringContext is an interface to support dynamic dispatch.
type IRaw_byte_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_BYTE_STRING() antlr.TerminalNode

	// IsRaw_byte_stringContext differentiates from other interfaces.
	IsRaw_byte_stringContext()
}

type Raw_byte_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaw_byte_stringContext() *Raw_byte_stringContext {
	var p = new(Raw_byte_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_raw_byte_string
	return p
}

func InitEmptyRaw_byte_stringContext(p *Raw_byte_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_raw_byte_string
}

func (*Raw_byte_stringContext) IsRaw_byte_stringContext() {}

func NewRaw_byte_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raw_byte_stringContext {
	var p = new(Raw_byte_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_raw_byte_string

	return p
}

func (s *Raw_byte_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Raw_byte_stringContext) RAW_BYTE_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRAW_BYTE_STRING, 0)
}

func (s *Raw_byte_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raw_byte_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raw_byte_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterRaw_byte_string(s)
	}
}

func (s *Raw_byte_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitRaw_byte_string(s)
	}
}

func (s *Raw_byte_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitRaw_byte_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Raw_byte_string() (localctx IRaw_byte_stringContext) {
	localctx = NewRaw_byte_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, BigQueryParserRULE_raw_byte_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(BigQueryParserRAW_BYTE_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecial_stringContext is an interface to support dynamic dispatch.
type ISpecial_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Datatype_name() IDatatype_nameContext
	QUOTED_STRING() antlr.TerminalNode

	// IsSpecial_stringContext differentiates from other interfaces.
	IsSpecial_stringContext()
}

type Special_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecial_stringContext() *Special_stringContext {
	var p = new(Special_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_special_string
	return p
}

func InitEmptySpecial_stringContext(p *Special_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_special_string
}

func (*Special_stringContext) IsSpecial_stringContext() {}

func NewSpecial_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Special_stringContext {
	var p = new(Special_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_special_string

	return p
}

func (s *Special_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Special_stringContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Special_stringContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserQUOTED_STRING, 0)
}

func (s *Special_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Special_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Special_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterSpecial_string(s)
	}
}

func (s *Special_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitSpecial_string(s)
	}
}

func (s *Special_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitSpecial_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Special_string() (localctx ISpecial_stringContext) {
	localctx = NewSpecial_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, BigQueryParserRULE_special_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Datatype_name()
	}
	{
		p.SetState(779)
		p.Match(BigQueryParserQUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASSERT_ROWS_MODIFIED() antlr.TerminalNode
	AT() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LOOKUP() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOT() antlr.TerminalNode
	S_NULL() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ON() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINAL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PROTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SAFE_OFFSET() antlr.TerminalNode
	SAFE_ORDINAL() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SSTRUCT() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TO() antlr.TerminalNode
	TREAT() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNION() antlr.TerminalNode
	UNNEST() antlr.TerminalNode
	USING() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHIN() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = BigQueryParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = BigQueryParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserALL, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAND, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserANY, 0)
}

func (s *KeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserARRAY, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAS, 0)
}

func (s *KeywordContext) ASC() antlr.TerminalNode {
	return s.GetToken(BigQueryParserASC, 0)
}

func (s *KeywordContext) ASSERT_ROWS_MODIFIED() antlr.TerminalNode {
	return s.GetToken(BigQueryParserASSERT_ROWS_MODIFIED, 0)
}

func (s *KeywordContext) AT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserAT, 0)
}

func (s *KeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBETWEEN, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(BigQueryParserBY, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCASE, 0)
}

func (s *KeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCAST, 0)
}

func (s *KeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCOLLATE, 0)
}

func (s *KeywordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCONTAINS, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCREATE, 0)
}

func (s *KeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCROSS, 0)
}

func (s *KeywordContext) CUBE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCUBE, 0)
}

func (s *KeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserCURRENT, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDEFAULT, 0)
}

func (s *KeywordContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDEFINE, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDESC, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserDISTINCT, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserELSE, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEND, 0)
}

func (s *KeywordContext) ENUM() antlr.TerminalNode {
	return s.GetToken(BigQueryParserENUM, 0)
}

func (s *KeywordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserESCAPE, 0)
}

func (s *KeywordContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXCEPT, 0)
}

func (s *KeywordContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXCLUDE, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXISTS, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserEXTRACT, 0)
}

func (s *KeywordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFALSE, 0)
}

func (s *KeywordContext) FETCH() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFETCH, 0)
}

func (s *KeywordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFOLLOWING, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFOR, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFROM, 0)
}

func (s *KeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserFULL, 0)
}

func (s *KeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGROUP, 0)
}

func (s *KeywordContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGROUPING, 0)
}

func (s *KeywordContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserGROUPS, 0)
}

func (s *KeywordContext) HASH() antlr.TerminalNode {
	return s.GetToken(BigQueryParserHASH, 0)
}

func (s *KeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserHAVING, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIF, 0)
}

func (s *KeywordContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIGNORE, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIN, 0)
}

func (s *KeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINNER, 0)
}

func (s *KeywordContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINTERSECT, 0)
}

func (s *KeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINTERVAL, 0)
}

func (s *KeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(BigQueryParserINTO, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserIS, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserJOIN, 0)
}

func (s *KeywordContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLATERAL, 0)
}

func (s *KeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLEFT, 0)
}

func (s *KeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLIKE, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLIMIT, 0)
}

func (s *KeywordContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(BigQueryParserLOOKUP, 0)
}

func (s *KeywordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserMERGE, 0)
}

func (s *KeywordContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNATURAL, 0)
}

func (s *KeywordContext) NEW() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNEW, 0)
}

func (s *KeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNO, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNOT, 0)
}

func (s *KeywordContext) S_NULL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserS_NULL, 0)
}

func (s *KeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserNULLS, 0)
}

func (s *KeywordContext) OF() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOF, 0)
}

func (s *KeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOFFSET, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(BigQueryParserON, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOR, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserORDER, 0)
}

func (s *KeywordContext) ORDINAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserORDINAL, 0)
}

func (s *KeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOUTER, 0)
}

func (s *KeywordContext) OVER() antlr.TerminalNode {
	return s.GetToken(BigQueryParserOVER, 0)
}

func (s *KeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(BigQueryParserPARTITION, 0)
}

func (s *KeywordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserPRECEDING, 0)
}

func (s *KeywordContext) PROTO() antlr.TerminalNode {
	return s.GetToken(BigQueryParserPROTO, 0)
}

func (s *KeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRANGE, 0)
}

func (s *KeywordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRECURSIVE, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserREPLACE, 0)
}

func (s *KeywordContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRESPECT, 0)
}

func (s *KeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserRIGHT, 0)
}

func (s *KeywordContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(BigQueryParserROLLUP, 0)
}

func (s *KeywordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(BigQueryParserROWS, 0)
}

func (s *KeywordContext) SAFE_OFFSET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSAFE_OFFSET, 0)
}

func (s *KeywordContext) SAFE_ORDINAL() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSAFE_ORDINAL, 0)
}

func (s *KeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSELECT, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSET, 0)
}

func (s *KeywordContext) SOME() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSOME, 0)
}

func (s *KeywordContext) SSTRUCT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSSTRUCT, 0)
}

func (s *KeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(BigQueryParserSYSTEM, 0)
}

func (s *KeywordContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTABLESAMPLE, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTHEN, 0)
}

func (s *KeywordContext) TIME() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTIME, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTO, 0)
}

func (s *KeywordContext) TREAT() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTREAT, 0)
}

func (s *KeywordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserTRUE, 0)
}

func (s *KeywordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNBOUNDED, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNION, 0)
}

func (s *KeywordContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUNNEST, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(BigQueryParserUSING, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWHEN, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWHERE, 0)
}

func (s *KeywordContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWINDOW, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWITH, 0)
}

func (s *KeywordContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(BigQueryParserWITHIN, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BigQueryParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case BigQueryParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *BigQueryParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, BigQueryParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4398046511103) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *BigQueryParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *Query_exprContext = nil
		if localctx != nil {
			t = localctx.(*Query_exprContext)
		}
		return p.Query_expr_Sempred(t, predIndex)

	case 8:
		var t *From_itemContext = nil
		if localctx != nil {
			t = localctx.(*From_itemContext)
		}
		return p.From_item_Sempred(t, predIndex)

	case 16:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *BigQueryParser) Query_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *BigQueryParser) From_item_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *BigQueryParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
