// Code generated from bigquery.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // bigquery
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type bigqueryParser struct {
	*antlr.BaseParser
}

var BigqueryParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func bigqueryParserInit() {
	staticData := &BigqueryParserStaticData
	staticData.LiteralNames = []string{
		"", "'('", "')'", "'.'", "'*'", "','", "'-'", "'~'", "'['", "']'", "'/'",
		"'+'", "'<<'", "'>>'", "'&'", "'^'", "'|'", "'='", "'<'", "'>'", "'<='",
		"'>='", "'!='", "'<>'", "'`'", "", "", "", "'''", "'\"'", "';'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "INT", "FLOAT", "DIGITS", "QUOTE", "DQOUTE",
		"SEMI", "ALL", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSERT_ROWS_MODIFIED",
		"AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE", "CONTAINS", "CREATE",
		"CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE", "DESC", "DISTINCT",
		"ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXTRACT",
		"FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "GROUP", "GROUPING",
		"GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN", "INNER", "INTERSECT",
		"INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LIKE", "LIMIT",
		"LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "S_NULL", "NULLS",
		"OF", "OFFSET", "ON", "OR", "ORDER", "ORDINAL", "OUTER", "OVER", "PARTITION",
		"PRECEDING", "PROTO", "RANGE", "RECURSIVE", "REPLACE", "RESPECT", "RIGHT",
		"ROLLUP", "ROWS", "SAFE_OFFSET", "SAFE_ORDINAL", "SELECT", "SET", "SOME",
		"SSTRUCT", "SYSTEM", "TABLESAMPLE", "THEN", "TIME", "TO", "TREAT", "TRUE",
		"UNBOUNDED", "UNION", "UNNEST", "USING", "WHEN", "WHERE", "WINDOW",
		"WITH", "WITHIN", "WS", "CMT", "M_CMT", "QUOTED_STRING", "TRIPLE_QUOTED_STRING",
		"RAW_STRING", "BYTE_STRING", "RAW_BYTE_STRING", "ID", "RB",
	}
	staticData.RuleNames = []string{
		"root", "stmtblock", "stmtmulti", "stmt", "query_statement", "query_expr",
		"select_statement", "from_statement", "from_item", "where_statement",
		"group_statement", "having_statement", "window_statement", "order_clause",
		"limit_clause", "unary_operator", "expr", "cast_expr", "column_expr",
		"except_statement", "replace_statement", "join_type", "on_clause", "set_op",
		"using_clause", "field_path", "sstruct", "array_expr", "array_path",
		"bool_expression", "window_name", "window_definition", "count", "skip_rows",
		"with_statement", "name", "alias_name", "array_name", "column_name",
		"cte_name", "dataset_name", "datatype_name", "function_name", "join_name",
		"member_name", "project_name", "struct_name", "table_name", "table_expr",
		"number", "integer_type", "float_type", "string", "quoted_string", "triple_quoted_string",
		"raw_string", "byte_string", "raw_byte_string", "special_string", "keyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 142, 783, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 127,
		8, 2, 5, 2, 129, 8, 2, 10, 2, 12, 2, 132, 9, 2, 1, 3, 1, 3, 1, 4, 3, 4,
		137, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 3, 5, 144, 8, 5, 1, 5, 3, 5, 147,
		8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 153, 8, 5, 1, 5, 3, 5, 156, 8, 5, 3,
		5, 158, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 164, 8, 5, 1, 5, 3, 5, 167,
		8, 5, 5, 5, 169, 8, 5, 10, 5, 12, 5, 172, 9, 5, 1, 6, 1, 6, 3, 6, 176,
		8, 6, 1, 6, 3, 6, 179, 8, 6, 1, 6, 3, 6, 182, 8, 6, 1, 6, 1, 6, 3, 6, 186,
		8, 6, 1, 6, 3, 6, 189, 8, 6, 1, 6, 1, 6, 3, 6, 193, 8, 6, 1, 6, 3, 6, 196,
		8, 6, 3, 6, 198, 8, 6, 1, 6, 1, 6, 3, 6, 202, 8, 6, 1, 6, 1, 6, 3, 6, 206,
		8, 6, 1, 6, 3, 6, 209, 8, 6, 1, 6, 1, 6, 3, 6, 213, 8, 6, 1, 6, 3, 6, 216,
		8, 6, 3, 6, 218, 8, 6, 5, 6, 220, 8, 6, 10, 6, 12, 6, 223, 9, 6, 1, 6,
		3, 6, 226, 8, 6, 1, 6, 3, 6, 229, 8, 6, 1, 6, 3, 6, 232, 8, 6, 1, 6, 3,
		6, 235, 8, 6, 1, 6, 3, 6, 238, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 244,
		8, 7, 10, 7, 12, 7, 247, 9, 7, 1, 8, 1, 8, 1, 8, 3, 8, 252, 8, 8, 1, 8,
		3, 8, 255, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 263, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 269, 8, 8, 1, 8, 3, 8, 272, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 280, 8, 8, 1, 8, 3, 8, 283, 8, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 288, 8, 8, 1, 8, 3, 8, 291, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 298, 8, 8, 1, 8, 3, 8, 301, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 306,
		8, 8, 1, 8, 3, 8, 309, 8, 8, 1, 8, 1, 8, 3, 8, 313, 8, 8, 1, 8, 3, 8, 316,
		8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 321, 8, 8, 1, 8, 3, 8, 324, 8, 8, 3, 8, 326,
		8, 8, 1, 8, 1, 8, 3, 8, 330, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 336, 8,
		8, 5, 8, 338, 8, 8, 10, 8, 12, 8, 341, 9, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 5, 10, 351, 8, 10, 10, 10, 12, 10, 354, 9, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 361, 8, 10, 10, 10, 12, 10, 364,
		9, 10, 1, 10, 1, 10, 3, 10, 368, 8, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13,
		384, 8, 13, 1, 13, 1, 13, 1, 13, 3, 13, 389, 8, 13, 5, 13, 391, 8, 13,
		10, 13, 12, 13, 394, 9, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 400, 8,
		14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 420, 8,
		16, 1, 16, 1, 16, 1, 16, 3, 16, 425, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 5, 16, 433, 8, 16, 10, 16, 12, 16, 436, 9, 16, 1, 16, 3,
		16, 439, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 5, 16, 452, 8, 16, 10, 16, 12, 16, 455, 9, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 3, 16, 461, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 3, 16, 490, 8, 16, 1, 16, 1, 16, 3, 16, 494, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 501, 8, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 513, 8, 16, 1, 16,
		1, 16, 1, 16, 3, 16, 518, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5,
		16, 525, 8, 16, 10, 16, 12, 16, 528, 9, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 538, 8, 16, 5, 16, 540, 8, 16, 10, 16,
		12, 16, 543, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 559, 8, 18, 1, 18,
		1, 18, 1, 18, 3, 18, 564, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 569, 8, 18,
		1, 18, 3, 18, 572, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 579,
		8, 19, 10, 19, 12, 19, 582, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1,
		20, 3, 20, 590, 8, 20, 1, 20, 3, 20, 593, 8, 20, 1, 20, 1, 20, 1, 20, 3,
		20, 598, 8, 20, 1, 20, 1, 20, 5, 20, 602, 8, 20, 10, 20, 12, 20, 605, 9,
		20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 613, 8, 21, 1, 21,
		1, 21, 3, 21, 617, 8, 21, 1, 21, 1, 21, 3, 21, 621, 8, 21, 3, 21, 623,
		8, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 630, 8, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 3, 23, 636, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		5, 24, 643, 8, 24, 10, 24, 12, 24, 646, 9, 24, 1, 24, 1, 24, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27,
		1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 32, 1, 32, 1,
		33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 1, 34, 1, 34, 5, 34, 687, 8, 34, 10, 34, 12, 34, 690, 9,
		34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 709, 8, 35, 1,
		36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 3, 48, 738, 8, 48, 1, 48, 1, 48,
		1, 48, 3, 48, 743, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 750,
		8, 48, 1, 49, 1, 49, 3, 49, 754, 8, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 766, 8, 52, 1, 53, 1, 53,
		1, 54, 1, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1,
		58, 1, 59, 1, 59, 1, 59, 0, 3, 10, 16, 32, 60, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
		0, 8, 2, 0, 31, 31, 52, 52, 2, 0, 36, 36, 51, 51, 2, 0, 6, 7, 90, 90, 3,
		0, 94, 94, 98, 98, 111, 112, 2, 0, 4, 4, 10, 10, 2, 0, 6, 6, 11, 11, 1,
		0, 12, 13, 1, 0, 31, 132, 862, 0, 120, 1, 0, 0, 0, 2, 122, 1, 0, 0, 0,
		4, 130, 1, 0, 0, 0, 6, 133, 1, 0, 0, 0, 8, 136, 1, 0, 0, 0, 10, 157, 1,
		0, 0, 0, 12, 173, 1, 0, 0, 0, 14, 239, 1, 0, 0, 0, 16, 325, 1, 0, 0, 0,
		18, 342, 1, 0, 0, 0, 20, 345, 1, 0, 0, 0, 22, 369, 1, 0, 0, 0, 24, 372,
		1, 0, 0, 0, 26, 379, 1, 0, 0, 0, 28, 395, 1, 0, 0, 0, 30, 401, 1, 0, 0,
		0, 32, 460, 1, 0, 0, 0, 34, 544, 1, 0, 0, 0, 36, 571, 1, 0, 0, 0, 38, 573,
		1, 0, 0, 0, 40, 585, 1, 0, 0, 0, 42, 622, 1, 0, 0, 0, 44, 624, 1, 0, 0,
		0, 46, 635, 1, 0, 0, 0, 48, 637, 1, 0, 0, 0, 50, 649, 1, 0, 0, 0, 52, 651,
		1, 0, 0, 0, 54, 656, 1, 0, 0, 0, 56, 661, 1, 0, 0, 0, 58, 663, 1, 0, 0,
		0, 60, 665, 1, 0, 0, 0, 62, 667, 1, 0, 0, 0, 64, 669, 1, 0, 0, 0, 66, 671,
		1, 0, 0, 0, 68, 673, 1, 0, 0, 0, 70, 708, 1, 0, 0, 0, 72, 710, 1, 0, 0,
		0, 74, 712, 1, 0, 0, 0, 76, 714, 1, 0, 0, 0, 78, 716, 1, 0, 0, 0, 80, 718,
		1, 0, 0, 0, 82, 720, 1, 0, 0, 0, 84, 722, 1, 0, 0, 0, 86, 724, 1, 0, 0,
		0, 88, 726, 1, 0, 0, 0, 90, 728, 1, 0, 0, 0, 92, 730, 1, 0, 0, 0, 94, 732,
		1, 0, 0, 0, 96, 749, 1, 0, 0, 0, 98, 753, 1, 0, 0, 0, 100, 755, 1, 0, 0,
		0, 102, 757, 1, 0, 0, 0, 104, 765, 1, 0, 0, 0, 106, 767, 1, 0, 0, 0, 108,
		769, 1, 0, 0, 0, 110, 771, 1, 0, 0, 0, 112, 773, 1, 0, 0, 0, 114, 775,
		1, 0, 0, 0, 116, 777, 1, 0, 0, 0, 118, 780, 1, 0, 0, 0, 120, 121, 3, 2,
		1, 0, 121, 1, 1, 0, 0, 0, 122, 123, 3, 4, 2, 0, 123, 3, 1, 0, 0, 0, 124,
		126, 3, 6, 3, 0, 125, 127, 5, 30, 0, 0, 126, 125, 1, 0, 0, 0, 126, 127,
		1, 0, 0, 0, 127, 129, 1, 0, 0, 0, 128, 124, 1, 0, 0, 0, 129, 132, 1, 0,
		0, 0, 130, 128, 1, 0, 0, 0, 130, 131, 1, 0, 0, 0, 131, 5, 1, 0, 0, 0, 132,
		130, 1, 0, 0, 0, 133, 134, 3, 8, 4, 0, 134, 7, 1, 0, 0, 0, 135, 137, 3,
		68, 34, 0, 136, 135, 1, 0, 0, 0, 136, 137, 1, 0, 0, 0, 137, 138, 1, 0,
		0, 0, 138, 139, 3, 10, 5, 0, 139, 9, 1, 0, 0, 0, 140, 141, 6, 5, -1, 0,
		141, 143, 3, 12, 6, 0, 142, 144, 3, 26, 13, 0, 143, 142, 1, 0, 0, 0, 143,
		144, 1, 0, 0, 0, 144, 146, 1, 0, 0, 0, 145, 147, 3, 28, 14, 0, 146, 145,
		1, 0, 0, 0, 146, 147, 1, 0, 0, 0, 147, 158, 1, 0, 0, 0, 148, 149, 5, 1,
		0, 0, 149, 150, 3, 10, 5, 0, 150, 152, 5, 2, 0, 0, 151, 153, 3, 26, 13,
		0, 152, 151, 1, 0, 0, 0, 152, 153, 1, 0, 0, 0, 153, 155, 1, 0, 0, 0, 154,
		156, 3, 28, 14, 0, 155, 154, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156, 158,
		1, 0, 0, 0, 157, 140, 1, 0, 0, 0, 157, 148, 1, 0, 0, 0, 158, 170, 1, 0,
		0, 0, 159, 160, 10, 1, 0, 0, 160, 161, 3, 46, 23, 0, 161, 163, 3, 10, 5,
		0, 162, 164, 3, 26, 13, 0, 163, 162, 1, 0, 0, 0, 163, 164, 1, 0, 0, 0,
		164, 166, 1, 0, 0, 0, 165, 167, 3, 28, 14, 0, 166, 165, 1, 0, 0, 0, 166,
		167, 1, 0, 0, 0, 167, 169, 1, 0, 0, 0, 168, 159, 1, 0, 0, 0, 169, 172,
		1, 0, 0, 0, 170, 168, 1, 0, 0, 0, 170, 171, 1, 0, 0, 0, 171, 11, 1, 0,
		0, 0, 172, 170, 1, 0, 0, 0, 173, 175, 5, 113, 0, 0, 174, 176, 7, 0, 0,
		0, 175, 174, 1, 0, 0, 0, 175, 176, 1, 0, 0, 0, 176, 197, 1, 0, 0, 0, 177,
		179, 3, 32, 16, 0, 178, 177, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0, 179, 181,
		1, 0, 0, 0, 180, 182, 5, 3, 0, 0, 181, 180, 1, 0, 0, 0, 181, 182, 1, 0,
		0, 0, 182, 183, 1, 0, 0, 0, 183, 185, 5, 4, 0, 0, 184, 186, 3, 38, 19,
		0, 185, 184, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 188, 1, 0, 0, 0, 187,
		189, 3, 40, 20, 0, 188, 187, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 198,
		1, 0, 0, 0, 190, 195, 3, 32, 16, 0, 191, 193, 5, 35, 0, 0, 192, 191, 1,
		0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0, 194, 196, 3, 72, 36,
		0, 195, 192, 1, 0, 0, 0, 195, 196, 1, 0, 0, 0, 196, 198, 1, 0, 0, 0, 197,
		178, 1, 0, 0, 0, 197, 190, 1, 0, 0, 0, 198, 221, 1, 0, 0, 0, 199, 217,
		5, 5, 0, 0, 200, 202, 3, 32, 16, 0, 201, 200, 1, 0, 0, 0, 201, 202, 1,
		0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 205, 5, 4, 0, 0, 204, 206, 3, 38, 19,
		0, 205, 204, 1, 0, 0, 0, 205, 206, 1, 0, 0, 0, 206, 208, 1, 0, 0, 0, 207,
		209, 3, 40, 20, 0, 208, 207, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 218,
		1, 0, 0, 0, 210, 215, 3, 32, 16, 0, 211, 213, 5, 35, 0, 0, 212, 211, 1,
		0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214, 1, 0, 0, 0, 214, 216, 3, 72, 36,
		0, 215, 212, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 218, 1, 0, 0, 0, 217,
		201, 1, 0, 0, 0, 217, 210, 1, 0, 0, 0, 218, 220, 1, 0, 0, 0, 219, 199,
		1, 0, 0, 0, 220, 223, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 221, 222, 1, 0,
		0, 0, 222, 225, 1, 0, 0, 0, 223, 221, 1, 0, 0, 0, 224, 226, 3, 14, 7, 0,
		225, 224, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 228, 1, 0, 0, 0, 227,
		229, 3, 18, 9, 0, 228, 227, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 231,
		1, 0, 0, 0, 230, 232, 3, 20, 10, 0, 231, 230, 1, 0, 0, 0, 231, 232, 1,
		0, 0, 0, 232, 234, 1, 0, 0, 0, 233, 235, 3, 22, 11, 0, 234, 233, 1, 0,
		0, 0, 234, 235, 1, 0, 0, 0, 235, 237, 1, 0, 0, 0, 236, 238, 3, 24, 12,
		0, 237, 236, 1, 0, 0, 0, 237, 238, 1, 0, 0, 0, 238, 13, 1, 0, 0, 0, 239,
		240, 5, 65, 0, 0, 240, 245, 3, 16, 8, 0, 241, 242, 5, 5, 0, 0, 242, 244,
		3, 16, 8, 0, 243, 241, 1, 0, 0, 0, 244, 247, 1, 0, 0, 0, 245, 243, 1, 0,
		0, 0, 245, 246, 1, 0, 0, 0, 246, 15, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0,
		248, 249, 6, 8, -1, 0, 249, 254, 3, 96, 48, 0, 250, 252, 5, 35, 0, 0, 251,
		250, 1, 0, 0, 0, 251, 252, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 255,
		3, 72, 36, 0, 254, 251, 1, 0, 0, 0, 254, 255, 1, 0, 0, 0, 255, 262, 1,
		0, 0, 0, 256, 257, 5, 64, 0, 0, 257, 258, 5, 117, 0, 0, 258, 259, 5, 120,
		0, 0, 259, 260, 5, 35, 0, 0, 260, 261, 5, 93, 0, 0, 261, 263, 3, 104, 52,
		0, 262, 256, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 326, 1, 0, 0, 0, 264,
		265, 5, 1, 0, 0, 265, 266, 3, 8, 4, 0, 266, 271, 5, 2, 0, 0, 267, 269,
		5, 35, 0, 0, 268, 267, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269, 270, 1, 0,
		0, 0, 270, 272, 3, 72, 36, 0, 271, 268, 1, 0, 0, 0, 271, 272, 1, 0, 0,
		0, 272, 326, 1, 0, 0, 0, 273, 326, 3, 50, 25, 0, 274, 275, 5, 126, 0, 0,
		275, 276, 5, 1, 0, 0, 276, 277, 3, 54, 27, 0, 277, 282, 5, 2, 0, 0, 278,
		280, 5, 35, 0, 0, 279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 281,
		1, 0, 0, 0, 281, 283, 3, 72, 36, 0, 282, 279, 1, 0, 0, 0, 282, 283, 1,
		0, 0, 0, 283, 290, 1, 0, 0, 0, 284, 285, 5, 131, 0, 0, 285, 287, 5, 94,
		0, 0, 286, 288, 5, 35, 0, 0, 287, 286, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0,
		288, 289, 1, 0, 0, 0, 289, 291, 3, 72, 36, 0, 290, 284, 1, 0, 0, 0, 290,
		291, 1, 0, 0, 0, 291, 326, 1, 0, 0, 0, 292, 293, 5, 126, 0, 0, 293, 294,
		5, 1, 0, 0, 294, 295, 3, 56, 28, 0, 295, 300, 5, 2, 0, 0, 296, 298, 5,
		35, 0, 0, 297, 296, 1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 299, 1, 0, 0,
		0, 299, 301, 3, 72, 36, 0, 300, 297, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0,
		301, 308, 1, 0, 0, 0, 302, 303, 5, 131, 0, 0, 303, 305, 5, 94, 0, 0, 304,
		306, 5, 35, 0, 0, 305, 304, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307,
		1, 0, 0, 0, 307, 309, 3, 72, 36, 0, 308, 302, 1, 0, 0, 0, 308, 309, 1,
		0, 0, 0, 309, 326, 1, 0, 0, 0, 310, 315, 3, 56, 28, 0, 311, 313, 5, 35,
		0, 0, 312, 311, 1, 0, 0, 0, 312, 313, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0,
		314, 316, 3, 72, 36, 0, 315, 312, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316,
		323, 1, 0, 0, 0, 317, 318, 5, 131, 0, 0, 318, 320, 5, 94, 0, 0, 319, 321,
		5, 35, 0, 0, 320, 319, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 322, 1, 0,
		0, 0, 322, 324, 3, 72, 36, 0, 323, 317, 1, 0, 0, 0, 323, 324, 1, 0, 0,
		0, 324, 326, 1, 0, 0, 0, 325, 248, 1, 0, 0, 0, 325, 264, 1, 0, 0, 0, 325,
		273, 1, 0, 0, 0, 325, 274, 1, 0, 0, 0, 325, 292, 1, 0, 0, 0, 325, 310,
		1, 0, 0, 0, 326, 339, 1, 0, 0, 0, 327, 329, 10, 6, 0, 0, 328, 330, 3, 42,
		21, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0,
		331, 332, 5, 80, 0, 0, 332, 335, 3, 16, 8, 0, 333, 336, 3, 44, 22, 0, 334,
		336, 3, 48, 24, 0, 335, 333, 1, 0, 0, 0, 335, 334, 1, 0, 0, 0, 336, 338,
		1, 0, 0, 0, 337, 327, 1, 0, 0, 0, 338, 341, 1, 0, 0, 0, 339, 337, 1, 0,
		0, 0, 339, 340, 1, 0, 0, 0, 340, 17, 1, 0, 0, 0, 341, 339, 1, 0, 0, 0,
		342, 343, 5, 129, 0, 0, 343, 344, 3, 58, 29, 0, 344, 19, 1, 0, 0, 0, 345,
		346, 5, 67, 0, 0, 346, 367, 5, 40, 0, 0, 347, 352, 3, 32, 16, 0, 348, 349,
		5, 5, 0, 0, 349, 351, 3, 32, 16, 0, 350, 348, 1, 0, 0, 0, 351, 354, 1,
		0, 0, 0, 352, 350, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 368, 1, 0, 0,
		0, 354, 352, 1, 0, 0, 0, 355, 356, 5, 109, 0, 0, 356, 357, 5, 1, 0, 0,
		357, 362, 3, 32, 16, 0, 358, 359, 5, 5, 0, 0, 359, 361, 3, 32, 16, 0, 360,
		358, 1, 0, 0, 0, 361, 364, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 362, 363,
		1, 0, 0, 0, 363, 365, 1, 0, 0, 0, 364, 362, 1, 0, 0, 0, 365, 366, 5, 2,
		0, 0, 366, 368, 1, 0, 0, 0, 367, 347, 1, 0, 0, 0, 367, 355, 1, 0, 0, 0,
		368, 21, 1, 0, 0, 0, 369, 370, 5, 71, 0, 0, 370, 371, 3, 58, 29, 0, 371,
		23, 1, 0, 0, 0, 372, 373, 5, 130, 0, 0, 373, 374, 3, 60, 30, 0, 374, 375,
		5, 35, 0, 0, 375, 376, 5, 1, 0, 0, 376, 377, 3, 62, 31, 0, 377, 378, 5,
		2, 0, 0, 378, 25, 1, 0, 0, 0, 379, 380, 5, 97, 0, 0, 380, 381, 5, 40, 0,
		0, 381, 383, 3, 32, 16, 0, 382, 384, 7, 1, 0, 0, 383, 382, 1, 0, 0, 0,
		383, 384, 1, 0, 0, 0, 384, 392, 1, 0, 0, 0, 385, 386, 5, 5, 0, 0, 386,
		388, 3, 32, 16, 0, 387, 389, 7, 1, 0, 0, 388, 387, 1, 0, 0, 0, 388, 389,
		1, 0, 0, 0, 389, 391, 1, 0, 0, 0, 390, 385, 1, 0, 0, 0, 391, 394, 1, 0,
		0, 0, 392, 390, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 27, 1, 0, 0, 0,
		394, 392, 1, 0, 0, 0, 395, 396, 5, 84, 0, 0, 396, 399, 3, 64, 32, 0, 397,
		398, 5, 94, 0, 0, 398, 400, 3, 66, 33, 0, 399, 397, 1, 0, 0, 0, 399, 400,
		1, 0, 0, 0, 400, 29, 1, 0, 0, 0, 401, 402, 7, 2, 0, 0, 402, 31, 1, 0, 0,
		0, 403, 404, 6, 16, -1, 0, 404, 461, 3, 98, 49, 0, 405, 461, 3, 104, 52,
		0, 406, 407, 3, 74, 37, 0, 407, 408, 5, 8, 0, 0, 408, 409, 7, 3, 0, 0,
		409, 410, 5, 1, 0, 0, 410, 411, 3, 32, 16, 0, 411, 412, 5, 2, 0, 0, 412,
		413, 5, 9, 0, 0, 413, 461, 1, 0, 0, 0, 414, 415, 3, 30, 15, 0, 415, 416,
		3, 32, 16, 20, 416, 461, 1, 0, 0, 0, 417, 419, 5, 79, 0, 0, 418, 420, 5,
		90, 0, 0, 419, 418, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 1, 0, 0,
		0, 421, 461, 5, 123, 0, 0, 422, 424, 5, 79, 0, 0, 423, 425, 5, 90, 0, 0,
		424, 423, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
		461, 5, 61, 0, 0, 427, 428, 3, 84, 42, 0, 428, 438, 5, 1, 0, 0, 429, 434,
		3, 32, 16, 0, 430, 431, 5, 5, 0, 0, 431, 433, 3, 32, 16, 0, 432, 430, 1,
		0, 0, 0, 433, 436, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0,
		0, 435, 439, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 437, 439, 5, 4, 0, 0, 438,
		429, 1, 0, 0, 0, 438, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 441,
		5, 2, 0, 0, 441, 461, 1, 0, 0, 0, 442, 461, 3, 34, 17, 0, 443, 444, 5,
		1, 0, 0, 444, 445, 3, 32, 16, 0, 445, 446, 5, 2, 0, 0, 446, 461, 1, 0,
		0, 0, 447, 448, 5, 8, 0, 0, 448, 453, 3, 32, 16, 0, 449, 450, 5, 5, 0,
		0, 450, 452, 3, 32, 16, 0, 451, 449, 1, 0, 0, 0, 452, 455, 1, 0, 0, 0,
		453, 451, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 456, 1, 0, 0, 0, 455,
		453, 1, 0, 0, 0, 456, 457, 5, 9, 0, 0, 457, 461, 1, 0, 0, 0, 458, 461,
		3, 36, 18, 0, 459, 461, 3, 118, 59, 0, 460, 403, 1, 0, 0, 0, 460, 405,
		1, 0, 0, 0, 460, 406, 1, 0, 0, 0, 460, 414, 1, 0, 0, 0, 460, 417, 1, 0,
		0, 0, 460, 422, 1, 0, 0, 0, 460, 427, 1, 0, 0, 0, 460, 442, 1, 0, 0, 0,
		460, 443, 1, 0, 0, 0, 460, 447, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460,
		459, 1, 0, 0, 0, 461, 541, 1, 0, 0, 0, 462, 463, 10, 19, 0, 0, 463, 464,
		7, 4, 0, 0, 464, 540, 3, 32, 16, 20, 465, 466, 10, 18, 0, 0, 466, 467,
		7, 5, 0, 0, 467, 540, 3, 32, 16, 19, 468, 469, 10, 17, 0, 0, 469, 470,
		7, 6, 0, 0, 470, 540, 3, 32, 16, 18, 471, 472, 10, 16, 0, 0, 472, 473,
		5, 14, 0, 0, 473, 540, 3, 32, 16, 17, 474, 475, 10, 15, 0, 0, 475, 476,
		5, 15, 0, 0, 476, 540, 3, 32, 16, 16, 477, 478, 10, 14, 0, 0, 478, 479,
		5, 16, 0, 0, 479, 540, 3, 32, 16, 15, 480, 500, 10, 13, 0, 0, 481, 501,
		5, 17, 0, 0, 482, 501, 5, 18, 0, 0, 483, 501, 5, 19, 0, 0, 484, 501, 5,
		20, 0, 0, 485, 501, 5, 21, 0, 0, 486, 501, 5, 22, 0, 0, 487, 501, 5, 23,
		0, 0, 488, 490, 5, 90, 0, 0, 489, 488, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0,
		490, 491, 1, 0, 0, 0, 491, 501, 5, 83, 0, 0, 492, 494, 5, 90, 0, 0, 493,
		492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 496,
		5, 39, 0, 0, 496, 497, 3, 32, 16, 0, 497, 498, 5, 32, 0, 0, 498, 499, 3,
		32, 16, 0, 499, 501, 1, 0, 0, 0, 500, 481, 1, 0, 0, 0, 500, 482, 1, 0,
		0, 0, 500, 483, 1, 0, 0, 0, 500, 484, 1, 0, 0, 0, 500, 485, 1, 0, 0, 0,
		500, 486, 1, 0, 0, 0, 500, 487, 1, 0, 0, 0, 500, 489, 1, 0, 0, 0, 500,
		493, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 540, 3, 32, 16, 14, 503, 504,
		10, 8, 0, 0, 504, 505, 5, 32, 0, 0, 505, 540, 3, 32, 16, 9, 506, 507, 10,
		7, 0, 0, 507, 508, 5, 96, 0, 0, 508, 540, 3, 32, 16, 8, 509, 510, 10, 12,
		0, 0, 510, 512, 5, 79, 0, 0, 511, 513, 5, 90, 0, 0, 512, 511, 1, 0, 0,
		0, 512, 513, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0, 514, 540, 5, 91, 0, 0, 515,
		517, 10, 9, 0, 0, 516, 518, 5, 90, 0, 0, 517, 516, 1, 0, 0, 0, 517, 518,
		1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 537, 5, 74, 0, 0, 520, 521, 5, 1,
		0, 0, 521, 526, 3, 32, 16, 0, 522, 523, 5, 5, 0, 0, 523, 525, 3, 32, 16,
		0, 524, 522, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 526,
		527, 1, 0, 0, 0, 527, 529, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529, 530,
		5, 2, 0, 0, 530, 538, 1, 0, 0, 0, 531, 538, 3, 8, 4, 0, 532, 533, 5, 126,
		0, 0, 533, 534, 5, 1, 0, 0, 534, 535, 3, 54, 27, 0, 535, 536, 5, 2, 0,
		0, 536, 538, 1, 0, 0, 0, 537, 520, 1, 0, 0, 0, 537, 531, 1, 0, 0, 0, 537,
		532, 1, 0, 0, 0, 538, 540, 1, 0, 0, 0, 539, 462, 1, 0, 0, 0, 539, 465,
		1, 0, 0, 0, 539, 468, 1, 0, 0, 0, 539, 471, 1, 0, 0, 0, 539, 474, 1, 0,
		0, 0, 539, 477, 1, 0, 0, 0, 539, 480, 1, 0, 0, 0, 539, 503, 1, 0, 0, 0,
		539, 506, 1, 0, 0, 0, 539, 509, 1, 0, 0, 0, 539, 515, 1, 0, 0, 0, 540,
		543, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 33, 1,
		0, 0, 0, 543, 541, 1, 0, 0, 0, 544, 545, 5, 42, 0, 0, 545, 546, 5, 1, 0,
		0, 546, 547, 3, 32, 16, 0, 547, 548, 5, 35, 0, 0, 548, 549, 3, 82, 41,
		0, 549, 550, 5, 2, 0, 0, 550, 35, 1, 0, 0, 0, 551, 552, 5, 24, 0, 0, 552,
		553, 3, 36, 18, 0, 553, 554, 5, 24, 0, 0, 554, 572, 1, 0, 0, 0, 555, 556,
		3, 90, 45, 0, 556, 557, 5, 3, 0, 0, 557, 559, 1, 0, 0, 0, 558, 555, 1,
		0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 561, 3, 80, 40,
		0, 561, 562, 5, 3, 0, 0, 562, 564, 1, 0, 0, 0, 563, 558, 1, 0, 0, 0, 563,
		564, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 3, 94, 47, 0, 566, 567,
		5, 3, 0, 0, 567, 569, 1, 0, 0, 0, 568, 563, 1, 0, 0, 0, 568, 569, 1, 0,
		0, 0, 569, 570, 1, 0, 0, 0, 570, 572, 3, 76, 38, 0, 571, 551, 1, 0, 0,
		0, 571, 568, 1, 0, 0, 0, 572, 37, 1, 0, 0, 0, 573, 574, 5, 57, 0, 0, 574,
		575, 5, 1, 0, 0, 575, 580, 3, 76, 38, 0, 576, 577, 5, 5, 0, 0, 577, 579,
		3, 76, 38, 0, 578, 576, 1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 578, 1,
		0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 583, 1, 0, 0, 0, 582, 580, 1, 0, 0,
		0, 583, 584, 5, 2, 0, 0, 584, 39, 1, 0, 0, 0, 585, 586, 5, 106, 0, 0, 586,
		587, 5, 1, 0, 0, 587, 592, 3, 32, 16, 0, 588, 590, 5, 35, 0, 0, 589, 588,
		1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 593, 3, 72,
		36, 0, 592, 589, 1, 0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 603, 1, 0, 0, 0,
		594, 595, 5, 5, 0, 0, 595, 597, 3, 32, 16, 0, 596, 598, 5, 35, 0, 0, 597,
		596, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 600,
		3, 72, 36, 0, 600, 602, 1, 0, 0, 0, 601, 594, 1, 0, 0, 0, 602, 605, 1,
		0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 606, 1, 0, 0,
		0, 605, 603, 1, 0, 0, 0, 606, 607, 5, 2, 0, 0, 607, 41, 1, 0, 0, 0, 608,
		623, 5, 75, 0, 0, 609, 623, 5, 46, 0, 0, 610, 612, 5, 66, 0, 0, 611, 613,
		5, 99, 0, 0, 612, 611, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 623, 1, 0,
		0, 0, 614, 616, 5, 82, 0, 0, 615, 617, 5, 99, 0, 0, 616, 615, 1, 0, 0,
		0, 616, 617, 1, 0, 0, 0, 617, 623, 1, 0, 0, 0, 618, 620, 5, 108, 0, 0,
		619, 621, 5, 99, 0, 0, 620, 619, 1, 0, 0, 0, 620, 621, 1, 0, 0, 0, 621,
		623, 1, 0, 0, 0, 622, 608, 1, 0, 0, 0, 622, 609, 1, 0, 0, 0, 622, 610,
		1, 0, 0, 0, 622, 614, 1, 0, 0, 0, 622, 618, 1, 0, 0, 0, 623, 43, 1, 0,
		0, 0, 624, 625, 5, 95, 0, 0, 625, 626, 3, 58, 29, 0, 626, 45, 1, 0, 0,
		0, 627, 629, 5, 125, 0, 0, 628, 630, 7, 0, 0, 0, 629, 628, 1, 0, 0, 0,
		629, 630, 1, 0, 0, 0, 630, 636, 1, 0, 0, 0, 631, 632, 5, 76, 0, 0, 632,
		636, 5, 52, 0, 0, 633, 634, 5, 57, 0, 0, 634, 636, 5, 52, 0, 0, 635, 627,
		1, 0, 0, 0, 635, 631, 1, 0, 0, 0, 635, 633, 1, 0, 0, 0, 636, 47, 1, 0,
		0, 0, 637, 638, 5, 127, 0, 0, 638, 639, 5, 1, 0, 0, 639, 644, 3, 86, 43,
		0, 640, 641, 5, 5, 0, 0, 641, 643, 3, 86, 43, 0, 642, 640, 1, 0, 0, 0,
		643, 646, 1, 0, 0, 0, 644, 642, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645,
		647, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 647, 648, 5, 2, 0, 0, 648, 49, 1,
		0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 51, 1, 0, 0, 0, 651, 652, 5, 116, 0,
		0, 652, 653, 5, 18, 0, 0, 653, 654, 3, 82, 41, 0, 654, 655, 5, 19, 0, 0,
		655, 53, 1, 0, 0, 0, 656, 657, 5, 34, 0, 0, 657, 658, 5, 18, 0, 0, 658,
		659, 3, 82, 41, 0, 659, 660, 5, 19, 0, 0, 660, 55, 1, 0, 0, 0, 661, 662,
		1, 0, 0, 0, 662, 57, 1, 0, 0, 0, 663, 664, 3, 32, 16, 0, 664, 59, 1, 0,
		0, 0, 665, 666, 1, 0, 0, 0, 666, 61, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0,
		668, 63, 1, 0, 0, 0, 669, 670, 3, 98, 49, 0, 670, 65, 1, 0, 0, 0, 671,
		672, 3, 98, 49, 0, 672, 67, 1, 0, 0, 0, 673, 674, 5, 131, 0, 0, 674, 675,
		3, 78, 39, 0, 675, 676, 5, 35, 0, 0, 676, 677, 5, 1, 0, 0, 677, 678, 3,
		10, 5, 0, 678, 688, 5, 2, 0, 0, 679, 680, 5, 5, 0, 0, 680, 681, 3, 78,
		39, 0, 681, 682, 5, 35, 0, 0, 682, 683, 5, 1, 0, 0, 683, 684, 3, 10, 5,
		0, 684, 685, 5, 2, 0, 0, 685, 687, 1, 0, 0, 0, 686, 679, 1, 0, 0, 0, 687,
		690, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 69, 1,
		0, 0, 0, 690, 688, 1, 0, 0, 0, 691, 709, 5, 141, 0, 0, 692, 693, 5, 29,
		0, 0, 693, 694, 3, 70, 35, 0, 694, 695, 5, 29, 0, 0, 695, 709, 1, 0, 0,
		0, 696, 697, 5, 1, 0, 0, 697, 698, 3, 70, 35, 0, 698, 699, 5, 2, 0, 0,
		699, 709, 1, 0, 0, 0, 700, 701, 5, 24, 0, 0, 701, 702, 3, 70, 35, 0, 702,
		703, 5, 24, 0, 0, 703, 709, 1, 0, 0, 0, 704, 705, 5, 28, 0, 0, 705, 706,
		3, 70, 35, 0, 706, 707, 5, 28, 0, 0, 707, 709, 1, 0, 0, 0, 708, 691, 1,
		0, 0, 0, 708, 692, 1, 0, 0, 0, 708, 696, 1, 0, 0, 0, 708, 700, 1, 0, 0,
		0, 708, 704, 1, 0, 0, 0, 709, 71, 1, 0, 0, 0, 710, 711, 3, 70, 35, 0, 711,
		73, 1, 0, 0, 0, 712, 713, 3, 70, 35, 0, 713, 75, 1, 0, 0, 0, 714, 715,
		3, 70, 35, 0, 715, 77, 1, 0, 0, 0, 716, 717, 3, 70, 35, 0, 717, 79, 1,
		0, 0, 0, 718, 719, 3, 70, 35, 0, 719, 81, 1, 0, 0, 0, 720, 721, 3, 70,
		35, 0, 721, 83, 1, 0, 0, 0, 722, 723, 3, 70, 35, 0, 723, 85, 1, 0, 0, 0,
		724, 725, 3, 70, 35, 0, 725, 87, 1, 0, 0, 0, 726, 727, 3, 70, 35, 0, 727,
		89, 1, 0, 0, 0, 728, 729, 3, 70, 35, 0, 729, 91, 1, 0, 0, 0, 730, 731,
		3, 70, 35, 0, 731, 93, 1, 0, 0, 0, 732, 733, 3, 70, 35, 0, 733, 95, 1,
		0, 0, 0, 734, 735, 3, 90, 45, 0, 735, 736, 5, 3, 0, 0, 736, 738, 1, 0,
		0, 0, 737, 734, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0,
		739, 740, 3, 80, 40, 0, 740, 741, 5, 3, 0, 0, 741, 743, 1, 0, 0, 0, 742,
		737, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 750,
		3, 94, 47, 0, 745, 746, 5, 24, 0, 0, 746, 747, 3, 96, 48, 0, 747, 748,
		5, 24, 0, 0, 748, 750, 1, 0, 0, 0, 749, 742, 1, 0, 0, 0, 749, 745, 1, 0,
		0, 0, 750, 97, 1, 0, 0, 0, 751, 754, 3, 100, 50, 0, 752, 754, 3, 102, 51,
		0, 753, 751, 1, 0, 0, 0, 753, 752, 1, 0, 0, 0, 754, 99, 1, 0, 0, 0, 755,
		756, 5, 25, 0, 0, 756, 101, 1, 0, 0, 0, 757, 758, 5, 26, 0, 0, 758, 103,
		1, 0, 0, 0, 759, 766, 3, 106, 53, 0, 760, 766, 3, 108, 54, 0, 761, 766,
		3, 110, 55, 0, 762, 766, 3, 112, 56, 0, 763, 766, 3, 114, 57, 0, 764, 766,
		3, 116, 58, 0, 765, 759, 1, 0, 0, 0, 765, 760, 1, 0, 0, 0, 765, 761, 1,
		0, 0, 0, 765, 762, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 765, 764, 1, 0, 0,
		0, 766, 105, 1, 0, 0, 0, 767, 768, 5, 136, 0, 0, 768, 107, 1, 0, 0, 0,
		769, 770, 5, 137, 0, 0, 770, 109, 1, 0, 0, 0, 771, 772, 5, 138, 0, 0, 772,
		111, 1, 0, 0, 0, 773, 774, 5, 139, 0, 0, 774, 113, 1, 0, 0, 0, 775, 776,
		5, 140, 0, 0, 776, 115, 1, 0, 0, 0, 777, 778, 3, 82, 41, 0, 778, 779, 5,
		136, 0, 0, 779, 117, 1, 0, 0, 0, 780, 781, 7, 7, 0, 0, 781, 119, 1, 0,
		0, 0, 98, 126, 130, 136, 143, 146, 152, 155, 157, 163, 166, 170, 175, 178,
		181, 185, 188, 192, 195, 197, 201, 205, 208, 212, 215, 217, 221, 225, 228,
		231, 234, 237, 245, 251, 254, 262, 268, 271, 279, 282, 287, 290, 297, 300,
		305, 308, 312, 315, 320, 323, 325, 329, 335, 339, 352, 362, 367, 383, 388,
		392, 399, 419, 424, 434, 438, 453, 460, 489, 493, 500, 512, 517, 526, 537,
		539, 541, 558, 563, 568, 571, 580, 589, 592, 597, 603, 612, 616, 620, 622,
		629, 635, 644, 688, 708, 737, 742, 749, 753, 765,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// bigqueryParserInit initializes any static state used to implement bigqueryParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewbigqueryParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BigqueryParserInit() {
	staticData := &BigqueryParserStaticData
	staticData.once.Do(bigqueryParserInit)
}

// NewbigqueryParser produces a new parser instance for the optional input antlr.TokenStream.
func NewbigqueryParser(input antlr.TokenStream) *bigqueryParser {
	BigqueryParserInit()
	this := new(bigqueryParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &BigqueryParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "bigquery.g4"

	return this
}

// bigqueryParser tokens.
const (
	bigqueryParserEOF                  = antlr.TokenEOF
	bigqueryParserT__0                 = 1
	bigqueryParserT__1                 = 2
	bigqueryParserT__2                 = 3
	bigqueryParserT__3                 = 4
	bigqueryParserT__4                 = 5
	bigqueryParserT__5                 = 6
	bigqueryParserT__6                 = 7
	bigqueryParserT__7                 = 8
	bigqueryParserT__8                 = 9
	bigqueryParserT__9                 = 10
	bigqueryParserT__10                = 11
	bigqueryParserT__11                = 12
	bigqueryParserT__12                = 13
	bigqueryParserT__13                = 14
	bigqueryParserT__14                = 15
	bigqueryParserT__15                = 16
	bigqueryParserT__16                = 17
	bigqueryParserT__17                = 18
	bigqueryParserT__18                = 19
	bigqueryParserT__19                = 20
	bigqueryParserT__20                = 21
	bigqueryParserT__21                = 22
	bigqueryParserT__22                = 23
	bigqueryParserT__23                = 24
	bigqueryParserINT                  = 25
	bigqueryParserFLOAT                = 26
	bigqueryParserDIGITS               = 27
	bigqueryParserQUOTE                = 28
	bigqueryParserDQOUTE               = 29
	bigqueryParserSEMI                 = 30
	bigqueryParserALL                  = 31
	bigqueryParserAND                  = 32
	bigqueryParserANY                  = 33
	bigqueryParserARRAY                = 34
	bigqueryParserAS                   = 35
	bigqueryParserASC                  = 36
	bigqueryParserASSERT_ROWS_MODIFIED = 37
	bigqueryParserAT                   = 38
	bigqueryParserBETWEEN              = 39
	bigqueryParserBY                   = 40
	bigqueryParserCASE                 = 41
	bigqueryParserCAST                 = 42
	bigqueryParserCOLLATE              = 43
	bigqueryParserCONTAINS             = 44
	bigqueryParserCREATE               = 45
	bigqueryParserCROSS                = 46
	bigqueryParserCUBE                 = 47
	bigqueryParserCURRENT              = 48
	bigqueryParserDEFAULT              = 49
	bigqueryParserDEFINE               = 50
	bigqueryParserDESC                 = 51
	bigqueryParserDISTINCT             = 52
	bigqueryParserELSE                 = 53
	bigqueryParserEND                  = 54
	bigqueryParserENUM                 = 55
	bigqueryParserESCAPE               = 56
	bigqueryParserEXCEPT               = 57
	bigqueryParserEXCLUDE              = 58
	bigqueryParserEXISTS               = 59
	bigqueryParserEXTRACT              = 60
	bigqueryParserFALSE                = 61
	bigqueryParserFETCH                = 62
	bigqueryParserFOLLOWING            = 63
	bigqueryParserFOR                  = 64
	bigqueryParserFROM                 = 65
	bigqueryParserFULL                 = 66
	bigqueryParserGROUP                = 67
	bigqueryParserGROUPING             = 68
	bigqueryParserGROUPS               = 69
	bigqueryParserHASH                 = 70
	bigqueryParserHAVING               = 71
	bigqueryParserIF                   = 72
	bigqueryParserIGNORE               = 73
	bigqueryParserIN                   = 74
	bigqueryParserINNER                = 75
	bigqueryParserINTERSECT            = 76
	bigqueryParserINTERVAL             = 77
	bigqueryParserINTO                 = 78
	bigqueryParserIS                   = 79
	bigqueryParserJOIN                 = 80
	bigqueryParserLATERAL              = 81
	bigqueryParserLEFT                 = 82
	bigqueryParserLIKE                 = 83
	bigqueryParserLIMIT                = 84
	bigqueryParserLOOKUP               = 85
	bigqueryParserMERGE                = 86
	bigqueryParserNATURAL              = 87
	bigqueryParserNEW                  = 88
	bigqueryParserNO                   = 89
	bigqueryParserNOT                  = 90
	bigqueryParserS_NULL               = 91
	bigqueryParserNULLS                = 92
	bigqueryParserOF                   = 93
	bigqueryParserOFFSET               = 94
	bigqueryParserON                   = 95
	bigqueryParserOR                   = 96
	bigqueryParserORDER                = 97
	bigqueryParserORDINAL              = 98
	bigqueryParserOUTER                = 99
	bigqueryParserOVER                 = 100
	bigqueryParserPARTITION            = 101
	bigqueryParserPRECEDING            = 102
	bigqueryParserPROTO                = 103
	bigqueryParserRANGE                = 104
	bigqueryParserRECURSIVE            = 105
	bigqueryParserREPLACE              = 106
	bigqueryParserRESPECT              = 107
	bigqueryParserRIGHT                = 108
	bigqueryParserROLLUP               = 109
	bigqueryParserROWS                 = 110
	bigqueryParserSAFE_OFFSET          = 111
	bigqueryParserSAFE_ORDINAL         = 112
	bigqueryParserSELECT               = 113
	bigqueryParserSET                  = 114
	bigqueryParserSOME                 = 115
	bigqueryParserSSTRUCT              = 116
	bigqueryParserSYSTEM               = 117
	bigqueryParserTABLESAMPLE          = 118
	bigqueryParserTHEN                 = 119
	bigqueryParserTIME                 = 120
	bigqueryParserTO                   = 121
	bigqueryParserTREAT                = 122
	bigqueryParserTRUE                 = 123
	bigqueryParserUNBOUNDED            = 124
	bigqueryParserUNION                = 125
	bigqueryParserUNNEST               = 126
	bigqueryParserUSING                = 127
	bigqueryParserWHEN                 = 128
	bigqueryParserWHERE                = 129
	bigqueryParserWINDOW               = 130
	bigqueryParserWITH                 = 131
	bigqueryParserWITHIN               = 132
	bigqueryParserWS                   = 133
	bigqueryParserCMT                  = 134
	bigqueryParserM_CMT                = 135
	bigqueryParserQUOTED_STRING        = 136
	bigqueryParserTRIPLE_QUOTED_STRING = 137
	bigqueryParserRAW_STRING           = 138
	bigqueryParserBYTE_STRING          = 139
	bigqueryParserRAW_BYTE_STRING      = 140
	bigqueryParserID                   = 141
	bigqueryParserRB                   = 142
)

// bigqueryParser rules.
const (
	bigqueryParserRULE_root                 = 0
	bigqueryParserRULE_stmtblock            = 1
	bigqueryParserRULE_stmtmulti            = 2
	bigqueryParserRULE_stmt                 = 3
	bigqueryParserRULE_query_statement      = 4
	bigqueryParserRULE_query_expr           = 5
	bigqueryParserRULE_select_statement     = 6
	bigqueryParserRULE_from_statement       = 7
	bigqueryParserRULE_from_item            = 8
	bigqueryParserRULE_where_statement      = 9
	bigqueryParserRULE_group_statement      = 10
	bigqueryParserRULE_having_statement     = 11
	bigqueryParserRULE_window_statement     = 12
	bigqueryParserRULE_order_clause         = 13
	bigqueryParserRULE_limit_clause         = 14
	bigqueryParserRULE_unary_operator       = 15
	bigqueryParserRULE_expr                 = 16
	bigqueryParserRULE_cast_expr            = 17
	bigqueryParserRULE_column_expr          = 18
	bigqueryParserRULE_except_statement     = 19
	bigqueryParserRULE_replace_statement    = 20
	bigqueryParserRULE_join_type            = 21
	bigqueryParserRULE_on_clause            = 22
	bigqueryParserRULE_set_op               = 23
	bigqueryParserRULE_using_clause         = 24
	bigqueryParserRULE_field_path           = 25
	bigqueryParserRULE_sstruct              = 26
	bigqueryParserRULE_array_expr           = 27
	bigqueryParserRULE_array_path           = 28
	bigqueryParserRULE_bool_expression      = 29
	bigqueryParserRULE_window_name          = 30
	bigqueryParserRULE_window_definition    = 31
	bigqueryParserRULE_count                = 32
	bigqueryParserRULE_skip_rows            = 33
	bigqueryParserRULE_with_statement       = 34
	bigqueryParserRULE_name                 = 35
	bigqueryParserRULE_alias_name           = 36
	bigqueryParserRULE_array_name           = 37
	bigqueryParserRULE_column_name          = 38
	bigqueryParserRULE_cte_name             = 39
	bigqueryParserRULE_dataset_name         = 40
	bigqueryParserRULE_datatype_name        = 41
	bigqueryParserRULE_function_name        = 42
	bigqueryParserRULE_join_name            = 43
	bigqueryParserRULE_member_name          = 44
	bigqueryParserRULE_project_name         = 45
	bigqueryParserRULE_struct_name          = 46
	bigqueryParserRULE_table_name           = 47
	bigqueryParserRULE_table_expr           = 48
	bigqueryParserRULE_number               = 49
	bigqueryParserRULE_integer_type         = 50
	bigqueryParserRULE_float_type           = 51
	bigqueryParserRULE_string               = 52
	bigqueryParserRULE_quoted_string        = 53
	bigqueryParserRULE_triple_quoted_string = 54
	bigqueryParserRULE_raw_string           = 55
	bigqueryParserRULE_byte_string          = 56
	bigqueryParserRULE_raw_byte_string      = 57
	bigqueryParserRULE_special_string       = 58
	bigqueryParserRULE_keyword              = 59
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmtblock() IStmtblockContext

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) Stmtblock() IStmtblockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtblockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtblockContext)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, bigqueryParserRULE_root)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(120)
		p.Stmtblock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtblockContext is an interface to support dynamic dispatch.
type IStmtblockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmtmulti() IStmtmultiContext

	// IsStmtblockContext differentiates from other interfaces.
	IsStmtblockContext()
}

type StmtblockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtblockContext() *StmtblockContext {
	var p = new(StmtblockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmtblock
	return p
}

func InitEmptyStmtblockContext(p *StmtblockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmtblock
}

func (*StmtblockContext) IsStmtblockContext() {}

func NewStmtblockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtblockContext {
	var p = new(StmtblockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_stmtblock

	return p
}

func (s *StmtblockContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtblockContext) Stmtmulti() IStmtmultiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtmultiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtmultiContext)
}

func (s *StmtblockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtblockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtblockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterStmtblock(s)
	}
}

func (s *StmtblockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitStmtblock(s)
	}
}

func (s *StmtblockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitStmtblock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Stmtblock() (localctx IStmtblockContext) {
	localctx = NewStmtblockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, bigqueryParserRULE_stmtblock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(122)
		p.Stmtmulti()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtmultiContext is an interface to support dynamic dispatch.
type IStmtmultiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStmtmultiContext differentiates from other interfaces.
	IsStmtmultiContext()
}

type StmtmultiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtmultiContext() *StmtmultiContext {
	var p = new(StmtmultiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmtmulti
	return p
}

func InitEmptyStmtmultiContext(p *StmtmultiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmtmulti
}

func (*StmtmultiContext) IsStmtmultiContext() {}

func NewStmtmultiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtmultiContext {
	var p = new(StmtmultiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_stmtmulti

	return p
}

func (s *StmtmultiContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtmultiContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *StmtmultiContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *StmtmultiContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserSEMI)
}

func (s *StmtmultiContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserSEMI, i)
}

func (s *StmtmultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtmultiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtmultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterStmtmulti(s)
	}
}

func (s *StmtmultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitStmtmulti(s)
	}
}

func (s *StmtmultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitStmtmulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Stmtmulti() (localctx IStmtmultiContext) {
	localctx = NewStmtmultiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, bigqueryParserRULE_stmtmulti)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bigqueryParserT__0 || _la == bigqueryParserSELECT || _la == bigqueryParserWITH {
		{
			p.SetState(124)
			p.Stmt()
		}
		p.SetState(126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserSEMI {
			{
				p.SetState(125)
				p.Match(bigqueryParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_statement() IQuery_statementContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, bigqueryParserRULE_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(133)
		p.Query_statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_statementContext is an interface to support dynamic dispatch.
type IQuery_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Query_expr() IQuery_exprContext
	With_statement() IWith_statementContext

	// IsQuery_statementContext differentiates from other interfaces.
	IsQuery_statementContext()
}

type Query_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_statementContext() *Query_statementContext {
	var p = new(Query_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_query_statement
	return p
}

func InitEmptyQuery_statementContext(p *Query_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_query_statement
}

func (*Query_statementContext) IsQuery_statementContext() {}

func NewQuery_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_statementContext {
	var p = new(Query_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_query_statement

	return p
}

func (s *Query_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_statementContext) Query_expr() IQuery_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *Query_statementContext) With_statement() IWith_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_statementContext)
}

func (s *Query_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterQuery_statement(s)
	}
}

func (s *Query_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitQuery_statement(s)
	}
}

func (s *Query_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitQuery_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Query_statement() (localctx IQuery_statementContext) {
	localctx = NewQuery_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, bigqueryParserRULE_query_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == bigqueryParserWITH {
		{
			p.SetState(135)
			p.With_statement()
		}

	}
	{
		p.SetState(138)
		p.query_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_exprContext is an interface to support dynamic dispatch.
type IQuery_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_statement() ISelect_statementContext
	Order_clause() IOrder_clauseContext
	Limit_clause() ILimit_clauseContext
	AllQuery_expr() []IQuery_exprContext
	Query_expr(i int) IQuery_exprContext
	Set_op() ISet_opContext

	// IsQuery_exprContext differentiates from other interfaces.
	IsQuery_exprContext()
}

type Query_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_exprContext() *Query_exprContext {
	var p = new(Query_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_query_expr
	return p
}

func InitEmptyQuery_exprContext(p *Query_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_query_expr
}

func (*Query_exprContext) IsQuery_exprContext() {}

func NewQuery_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_exprContext {
	var p = new(Query_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_query_expr

	return p
}

func (s *Query_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_exprContext) Select_statement() ISelect_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Query_exprContext) Order_clause() IOrder_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_clauseContext)
}

func (s *Query_exprContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Query_exprContext) AllQuery_expr() []IQuery_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_exprContext); ok {
			len++
		}
	}

	tst := make([]IQuery_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_exprContext); ok {
			tst[i] = t.(IQuery_exprContext)
			i++
		}
	}

	return tst
}

func (s *Query_exprContext) Query_expr(i int) IQuery_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *Query_exprContext) Set_op() ISet_opContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_opContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_opContext)
}

func (s *Query_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterQuery_expr(s)
	}
}

func (s *Query_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitQuery_expr(s)
	}
}

func (s *Query_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitQuery_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Query_expr() (localctx IQuery_exprContext) {
	return p.query_expr(0)
}

func (p *bigqueryParser) query_expr(_p int) (localctx IQuery_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQuery_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQuery_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, bigqueryParserRULE_query_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserSELECT:
		{
			p.SetState(141)
			p.Select_statement()
		}
		p.SetState(143)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(142)
				p.Order_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(146)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(145)
				p.Limit_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case bigqueryParserT__0:
		{
			p.SetState(148)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(149)
			p.query_expr(0)
		}
		{
			p.SetState(150)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(151)
				p.Order_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(154)
				p.Limit_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewQuery_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_query_expr)
			p.SetState(159)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(160)
				p.Set_op()
			}
			{
				p.SetState(161)
				p.query_expr(0)
			}
			p.SetState(163)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(162)
					p.Order_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(166)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(165)
					p.Limit_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	From_statement() IFrom_statementContext
	Where_statement() IWhere_statementContext
	Group_statement() IGroup_statementContext
	Having_statement() IHaving_statementContext
	Window_statement() IWindow_statementContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	AllExcept_statement() []IExcept_statementContext
	Except_statement(i int) IExcept_statementContext
	AllReplace_statement() []IReplace_statementContext
	Replace_statement(i int) IReplace_statementContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_select_statement
	return p
}

func InitEmptySelect_statementContext(p *Select_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_select_statement
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSELECT, 0)
}

func (s *Select_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_statementContext) From_statement() IFrom_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_statementContext)
}

func (s *Select_statementContext) Where_statement() IWhere_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_statementContext)
}

func (s *Select_statementContext) Group_statement() IGroup_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_statementContext)
}

func (s *Select_statementContext) Having_statement() IHaving_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_statementContext)
}

func (s *Select_statementContext) Window_statement() IWindow_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_statementContext)
}

func (s *Select_statementContext) ALL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserALL, 0)
}

func (s *Select_statementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDISTINCT, 0)
}

func (s *Select_statementContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *Select_statementContext) AllExcept_statement() []IExcept_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExcept_statementContext); ok {
			len++
		}
	}

	tst := make([]IExcept_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExcept_statementContext); ok {
			tst[i] = t.(IExcept_statementContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Except_statement(i int) IExcept_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcept_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcept_statementContext)
}

func (s *Select_statementContext) AllReplace_statement() []IReplace_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplace_statementContext); ok {
			len++
		}
	}

	tst := make([]IReplace_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplace_statementContext); ok {
			tst[i] = t.(IReplace_statementContext)
			i++
		}
	}

	return tst
}

func (s *Select_statementContext) Replace_statement(i int) IReplace_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_statementContext)
}

func (s *Select_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserAS)
}

func (s *Select_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, i)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterSelect_statement(s)
	}
}

func (s *Select_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitSelect_statement(s)
	}
}

func (s *Select_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitSelect_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, bigqueryParserRULE_select_statement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(173)
		p.Match(bigqueryParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(175)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(174)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bigqueryParserALL || _la == bigqueryParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.SetState(178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1224736318) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&16159) != 0) {
			{
				p.SetState(177)
				p.expr(0)
			}

		}
		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserT__2 {
			{
				p.SetState(180)
				p.Match(bigqueryParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(183)
			p.Match(bigqueryParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(184)
				p.Except_statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(188)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(187)
				p.Replace_statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(190)
			p.expr(0)
		}
		p.SetState(195)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			p.SetState(192)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(191)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(194)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(199)
				p.Match(bigqueryParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
			case 1:
				p.SetState(201)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1224736318) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&16159) != 0) {
					{
						p.SetState(200)
						p.expr(0)
					}

				}
				{
					p.SetState(203)
					p.Match(bigqueryParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(205)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(204)
						p.Except_statement()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(208)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(207)
						p.Replace_statement()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 2:
				{
					p.SetState(210)
					p.expr(0)
				}
				p.SetState(215)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
					p.SetState(212)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == bigqueryParserAS {
						{
							p.SetState(211)
							p.Match(bigqueryParserAS)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(214)
						p.Alias_name()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(224)
			p.From_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(228)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(227)
			p.Where_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(230)
			p.Group_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(233)
			p.Having_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(236)
			p.Window_statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_statementContext is an interface to support dynamic dispatch.
type IFrom_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	AllFrom_item() []IFrom_itemContext
	From_item(i int) IFrom_itemContext

	// IsFrom_statementContext differentiates from other interfaces.
	IsFrom_statementContext()
}

type From_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_statementContext() *From_statementContext {
	var p = new(From_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_from_statement
	return p
}

func InitEmptyFrom_statementContext(p *From_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_from_statement
}

func (*From_statementContext) IsFrom_statementContext() {}

func NewFrom_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_statementContext {
	var p = new(From_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_from_statement

	return p
}

func (s *From_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *From_statementContext) FROM() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFROM, 0)
}

func (s *From_statementContext) AllFrom_item() []IFrom_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_itemContext); ok {
			len++
		}
	}

	tst := make([]IFrom_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_itemContext); ok {
			tst[i] = t.(IFrom_itemContext)
			i++
		}
	}

	return tst
}

func (s *From_statementContext) From_item(i int) IFrom_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_itemContext)
}

func (s *From_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterFrom_statement(s)
	}
}

func (s *From_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitFrom_statement(s)
	}
}

func (s *From_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitFrom_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) From_statement() (localctx IFrom_statementContext) {
	localctx = NewFrom_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, bigqueryParserRULE_from_statement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Match(bigqueryParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(240)
		p.from_item(0)
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(241)
				p.Match(bigqueryParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(242)
				p.from_item(0)
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_itemContext is an interface to support dynamic dispatch.
type IFrom_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_expr() ITable_exprContext
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	FOR() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TIME() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	OF() antlr.TerminalNode
	String_() IStringContext
	Query_statement() IQuery_statementContext
	Field_path() IField_pathContext
	UNNEST() antlr.TerminalNode
	Array_expr() IArray_exprContext
	WITH() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	Array_path() IArray_pathContext
	AllFrom_item() []IFrom_itemContext
	From_item(i int) IFrom_itemContext
	JOIN() antlr.TerminalNode
	On_clause() IOn_clauseContext
	Using_clause() IUsing_clauseContext
	Join_type() IJoin_typeContext

	// IsFrom_itemContext differentiates from other interfaces.
	IsFrom_itemContext()
}

type From_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_itemContext() *From_itemContext {
	var p = new(From_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_from_item
	return p
}

func InitEmptyFrom_itemContext(p *From_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_from_item
}

func (*From_itemContext) IsFrom_itemContext() {}

func NewFrom_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_itemContext {
	var p = new(From_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_from_item

	return p
}

func (s *From_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *From_itemContext) Table_expr() ITable_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_exprContext)
}

func (s *From_itemContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *From_itemContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *From_itemContext) FOR() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFOR, 0)
}

func (s *From_itemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSYSTEM, 0)
}

func (s *From_itemContext) TIME() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTIME, 0)
}

func (s *From_itemContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserAS)
}

func (s *From_itemContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, i)
}

func (s *From_itemContext) OF() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOF, 0)
}

func (s *From_itemContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *From_itemContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *From_itemContext) Field_path() IField_pathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_pathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_pathContext)
}

func (s *From_itemContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNNEST, 0)
}

func (s *From_itemContext) Array_expr() IArray_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_exprContext)
}

func (s *From_itemContext) WITH() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWITH, 0)
}

func (s *From_itemContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOFFSET, 0)
}

func (s *From_itemContext) Array_path() IArray_pathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_pathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_pathContext)
}

func (s *From_itemContext) AllFrom_item() []IFrom_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_itemContext); ok {
			len++
		}
	}

	tst := make([]IFrom_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_itemContext); ok {
			tst[i] = t.(IFrom_itemContext)
			i++
		}
	}

	return tst
}

func (s *From_itemContext) From_item(i int) IFrom_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_itemContext)
}

func (s *From_itemContext) JOIN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserJOIN, 0)
}

func (s *From_itemContext) On_clause() IOn_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOn_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOn_clauseContext)
}

func (s *From_itemContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *From_itemContext) Join_type() IJoin_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_typeContext)
}

func (s *From_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterFrom_item(s)
	}
}

func (s *From_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitFrom_item(s)
	}
}

func (s *From_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitFrom_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) From_item() (localctx IFrom_itemContext) {
	return p.from_item(0)
}

func (p *bigqueryParser) from_item(_p int) (localctx IFrom_itemContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFrom_itemContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFrom_itemContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 16
	p.EnterRecursionRule(localctx, 16, bigqueryParserRULE_from_item, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(249)
			p.Table_expr()
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(250)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(253)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(256)
				p.Match(bigqueryParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(257)
				p.Match(bigqueryParserSYSTEM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(258)
				p.Match(bigqueryParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(259)
				p.Match(bigqueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(260)
				p.Match(bigqueryParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(261)
				p.String_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(264)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(265)
			p.Query_statement()
		}
		{
			p.SetState(266)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(267)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(270)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(273)
			p.Field_path()
		}

	case 4:
		{
			p.SetState(274)
			p.Match(bigqueryParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(275)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(276)
			p.Array_expr()
		}
		{
			p.SetState(277)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			p.SetState(279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(278)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(281)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(290)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(284)
				p.Match(bigqueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(285)
				p.Match(bigqueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(287)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(286)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(289)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		{
			p.SetState(292)
			p.Match(bigqueryParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(293)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(294)
			p.Array_path()
		}
		{
			p.SetState(295)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			p.SetState(297)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(296)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(299)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(302)
				p.Match(bigqueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(303)
				p.Match(bigqueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(305)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(304)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(307)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		{
			p.SetState(310)
			p.Array_path()
		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			p.SetState(312)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(311)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(314)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(317)
				p.Match(bigqueryParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(318)
				p.Match(bigqueryParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(320)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == bigqueryParserAS {
				{
					p.SetState(319)
					p.Match(bigqueryParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(322)
				p.Alias_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFrom_itemContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_from_item)
			p.SetState(327)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				goto errorExit
			}
			p.SetState(329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-46)) & ^0x3f) == 0 && ((int64(1)<<(_la-46))&4611686087684784129) != 0 {
				{
					p.SetState(328)
					p.Join_type()
				}

			}
			{
				p.SetState(331)
				p.Match(bigqueryParserJOIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(332)
				p.from_item(0)
			}
			p.SetState(335)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case bigqueryParserON:
				{
					p.SetState(333)
					p.On_clause()
				}

			case bigqueryParserUSING:
				{
					p.SetState(334)
					p.Using_clause()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhere_statementContext is an interface to support dynamic dispatch.
type IWhere_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsWhere_statementContext differentiates from other interfaces.
	IsWhere_statementContext()
}

type Where_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_statementContext() *Where_statementContext {
	var p = new(Where_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_where_statement
	return p
}

func InitEmptyWhere_statementContext(p *Where_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_where_statement
}

func (*Where_statementContext) IsWhere_statementContext() {}

func NewWhere_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_statementContext {
	var p = new(Where_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_where_statement

	return p
}

func (s *Where_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWHERE, 0)
}

func (s *Where_statementContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *Where_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterWhere_statement(s)
	}
}

func (s *Where_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitWhere_statement(s)
	}
}

func (s *Where_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitWhere_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Where_statement() (localctx IWhere_statementContext) {
	localctx = NewWhere_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, bigqueryParserRULE_where_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(342)
		p.Match(bigqueryParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(343)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_statementContext is an interface to support dynamic dispatch.
type IGroup_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsGroup_statementContext differentiates from other interfaces.
	IsGroup_statementContext()
}

type Group_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_statementContext() *Group_statementContext {
	var p = new(Group_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_group_statement
	return p
}

func InitEmptyGroup_statementContext(p *Group_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_group_statement
}

func (*Group_statementContext) IsGroup_statementContext() {}

func NewGroup_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_statementContext {
	var p = new(Group_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_group_statement

	return p
}

func (s *Group_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_statementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(bigqueryParserGROUP, 0)
}

func (s *Group_statementContext) BY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBY, 0)
}

func (s *Group_statementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(bigqueryParserROLLUP, 0)
}

func (s *Group_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Group_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Group_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterGroup_statement(s)
	}
}

func (s *Group_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitGroup_statement(s)
	}
}

func (s *Group_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitGroup_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Group_statement() (localctx IGroup_statementContext) {
	localctx = NewGroup_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, bigqueryParserRULE_group_statement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.Match(bigqueryParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(346)
		p.Match(bigqueryParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(347)
			p.expr(0)
		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(348)
					p.Match(bigqueryParserT__4)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(349)
					p.expr(0)
				}

			}
			p.SetState(354)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(355)
			p.Match(bigqueryParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.expr(0)
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == bigqueryParserT__4 {
			{
				p.SetState(358)
				p.Match(bigqueryParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(359)
				p.expr(0)
			}

			p.SetState(364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(365)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHaving_statementContext is an interface to support dynamic dispatch.
type IHaving_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsHaving_statementContext differentiates from other interfaces.
	IsHaving_statementContext()
}

type Having_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_statementContext() *Having_statementContext {
	var p = new(Having_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_having_statement
	return p
}

func InitEmptyHaving_statementContext(p *Having_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_having_statement
}

func (*Having_statementContext) IsHaving_statementContext() {}

func NewHaving_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_statementContext {
	var p = new(Having_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_having_statement

	return p
}

func (s *Having_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_statementContext) HAVING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserHAVING, 0)
}

func (s *Having_statementContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *Having_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterHaving_statement(s)
	}
}

func (s *Having_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitHaving_statement(s)
	}
}

func (s *Having_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitHaving_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Having_statement() (localctx IHaving_statementContext) {
	localctx = NewHaving_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, bigqueryParserRULE_having_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(bigqueryParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(370)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_statementContext is an interface to support dynamic dispatch.
type IWindow_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Window_name() IWindow_nameContext
	AS() antlr.TerminalNode
	Window_definition() IWindow_definitionContext

	// IsWindow_statementContext differentiates from other interfaces.
	IsWindow_statementContext()
}

type Window_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_statementContext() *Window_statementContext {
	var p = new(Window_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_statement
	return p
}

func InitEmptyWindow_statementContext(p *Window_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_statement
}

func (*Window_statementContext) IsWindow_statementContext() {}

func NewWindow_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_statementContext {
	var p = new(Window_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_window_statement

	return p
}

func (s *Window_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_statementContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWINDOW, 0)
}

func (s *Window_statementContext) Window_name() IWindow_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_nameContext)
}

func (s *Window_statementContext) AS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, 0)
}

func (s *Window_statementContext) Window_definition() IWindow_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_definitionContext)
}

func (s *Window_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterWindow_statement(s)
	}
}

func (s *Window_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitWindow_statement(s)
	}
}

func (s *Window_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitWindow_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Window_statement() (localctx IWindow_statementContext) {
	localctx = NewWindow_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, bigqueryParserRULE_window_statement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(bigqueryParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(373)
		p.Window_name()
	}
	{
		p.SetState(374)
		p.Match(bigqueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(376)
		p.Window_definition()
	}
	{
		p.SetState(377)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_clauseContext is an interface to support dynamic dispatch.
type IOrder_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllASC() []antlr.TerminalNode
	ASC(i int) antlr.TerminalNode
	AllDESC() []antlr.TerminalNode
	DESC(i int) antlr.TerminalNode

	// IsOrder_clauseContext differentiates from other interfaces.
	IsOrder_clauseContext()
}

type Order_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_clauseContext() *Order_clauseContext {
	var p = new(Order_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_order_clause
	return p
}

func InitEmptyOrder_clauseContext(p *Order_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_order_clause
}

func (*Order_clauseContext) IsOrder_clauseContext() {}

func NewOrder_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_clauseContext {
	var p = new(Order_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_order_clause

	return p
}

func (s *Order_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_clauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserORDER, 0)
}

func (s *Order_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBY, 0)
}

func (s *Order_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Order_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Order_clauseContext) AllASC() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserASC)
}

func (s *Order_clauseContext) ASC(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserASC, i)
}

func (s *Order_clauseContext) AllDESC() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserDESC)
}

func (s *Order_clauseContext) DESC(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserDESC, i)
}

func (s *Order_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterOrder_clause(s)
	}
}

func (s *Order_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitOrder_clause(s)
	}
}

func (s *Order_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitOrder_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Order_clause() (localctx IOrder_clauseContext) {
	localctx = NewOrder_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, bigqueryParserRULE_order_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(bigqueryParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.Match(bigqueryParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)
		p.expr(0)
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			_la = p.GetTokenStream().LA(1)

			if !(_la == bigqueryParserASC || _la == bigqueryParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(385)
				p.Match(bigqueryParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(386)
				p.expr(0)
			}
			p.SetState(388)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(387)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bigqueryParserASC || _la == bigqueryParserDESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_clauseContext is an interface to support dynamic dispatch.
type ILimit_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Count() ICountContext
	OFFSET() antlr.TerminalNode
	Skip_rows() ISkip_rowsContext

	// IsLimit_clauseContext differentiates from other interfaces.
	IsLimit_clauseContext()
}

type Limit_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_clauseContext() *Limit_clauseContext {
	var p = new(Limit_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_limit_clause
	return p
}

func InitEmptyLimit_clauseContext(p *Limit_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_limit_clause
}

func (*Limit_clauseContext) IsLimit_clauseContext() {}

func NewLimit_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_clauseContext {
	var p = new(Limit_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_limit_clause

	return p
}

func (s *Limit_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_clauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLIMIT, 0)
}

func (s *Limit_clauseContext) Count() ICountContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountContext)
}

func (s *Limit_clauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOFFSET, 0)
}

func (s *Limit_clauseContext) Skip_rows() ISkip_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkip_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkip_rowsContext)
}

func (s *Limit_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterLimit_clause(s)
	}
}

func (s *Limit_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitLimit_clause(s)
	}
}

func (s *Limit_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitLimit_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Limit_clause() (localctx ILimit_clauseContext) {
	localctx = NewLimit_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, bigqueryParserRULE_limit_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(bigqueryParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(396)
		p.Count()
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(397)
			p.Match(bigqueryParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(398)
			p.Skip_rows()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_unary_operator
	return p
}

func InitEmptyUnary_operatorContext(p *Unary_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_unary_operator
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNOT, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (s *Unary_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitUnary_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, bigqueryParserRULE_unary_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		_la = p.GetTokenStream().LA(1)

		if !(_la == bigqueryParserT__5 || _la == bigqueryParserT__6 || _la == bigqueryParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	String_() IStringContext
	Array_name() IArray_nameContext
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	OFFSET() antlr.TerminalNode
	ORDINAL() antlr.TerminalNode
	SAFE_OFFSET() antlr.TerminalNode
	SAFE_ORDINAL() antlr.TerminalNode
	Unary_operator() IUnary_operatorContext
	IS() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	NOT() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	Function_name() IFunction_nameContext
	Cast_expr() ICast_exprContext
	Column_expr() IColumn_exprContext
	Keyword() IKeywordContext
	LIKE() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode
	S_NULL() antlr.TerminalNode
	IN() antlr.TerminalNode
	Query_statement() IQuery_statementContext
	UNNEST() antlr.TerminalNode
	Array_expr() IArray_exprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ExprContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExprContext) Array_name() IArray_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_nameContext)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOFFSET, 0)
}

func (s *ExprContext) ORDINAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserORDINAL, 0)
}

func (s *ExprContext) SAFE_OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSAFE_OFFSET, 0)
}

func (s *ExprContext) SAFE_ORDINAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSAFE_ORDINAL, 0)
}

func (s *ExprContext) Unary_operator() IUnary_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *ExprContext) IS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIS, 0)
}

func (s *ExprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTRUE, 0)
}

func (s *ExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNOT, 0)
}

func (s *ExprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFALSE, 0)
}

func (s *ExprContext) Function_name() IFunction_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *ExprContext) Cast_expr() ICast_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_exprContext)
}

func (s *ExprContext) Column_expr() IColumn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_exprContext)
}

func (s *ExprContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ExprContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLIKE, 0)
}

func (s *ExprContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBETWEEN, 0)
}

func (s *ExprContext) AND() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAND, 0)
}

func (s *ExprContext) OR() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOR, 0)
}

func (s *ExprContext) S_NULL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserS_NULL, 0)
}

func (s *ExprContext) IN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIN, 0)
}

func (s *ExprContext) Query_statement() IQuery_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_statementContext)
}

func (s *ExprContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNNEST, 0)
}

func (s *ExprContext) Array_expr() IArray_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArray_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArray_exprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *bigqueryParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, bigqueryParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(404)
			p.Number()
		}

	case 2:
		{
			p.SetState(405)
			p.String_()
		}

	case 3:
		{
			p.SetState(406)
			p.Array_name()
		}
		{
			p.SetState(407)
			p.Match(bigqueryParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(408)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&393233) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(409)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(410)
			p.expr(0)
		}
		{
			p.SetState(411)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(412)
			p.Match(bigqueryParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(414)
			p.Unary_operator()
		}
		{
			p.SetState(415)
			p.expr(20)
		}

	case 5:
		{
			p.SetState(417)
			p.Match(bigqueryParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserNOT {
			{
				p.SetState(418)
				p.Match(bigqueryParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(421)
			p.Match(bigqueryParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(422)
			p.Match(bigqueryParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserNOT {
			{
				p.SetState(423)
				p.Match(bigqueryParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(426)
			p.Match(bigqueryParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		{
			p.SetState(427)
			p.Function_name()
		}
		{
			p.SetState(428)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case bigqueryParserT__0, bigqueryParserT__5, bigqueryParserT__6, bigqueryParserT__7, bigqueryParserT__23, bigqueryParserINT, bigqueryParserFLOAT, bigqueryParserQUOTE, bigqueryParserDQOUTE, bigqueryParserALL, bigqueryParserAND, bigqueryParserANY, bigqueryParserARRAY, bigqueryParserAS, bigqueryParserASC, bigqueryParserASSERT_ROWS_MODIFIED, bigqueryParserAT, bigqueryParserBETWEEN, bigqueryParserBY, bigqueryParserCASE, bigqueryParserCAST, bigqueryParserCOLLATE, bigqueryParserCONTAINS, bigqueryParserCREATE, bigqueryParserCROSS, bigqueryParserCUBE, bigqueryParserCURRENT, bigqueryParserDEFAULT, bigqueryParserDEFINE, bigqueryParserDESC, bigqueryParserDISTINCT, bigqueryParserELSE, bigqueryParserEND, bigqueryParserENUM, bigqueryParserESCAPE, bigqueryParserEXCEPT, bigqueryParserEXCLUDE, bigqueryParserEXISTS, bigqueryParserEXTRACT, bigqueryParserFALSE, bigqueryParserFETCH, bigqueryParserFOLLOWING, bigqueryParserFOR, bigqueryParserFROM, bigqueryParserFULL, bigqueryParserGROUP, bigqueryParserGROUPING, bigqueryParserGROUPS, bigqueryParserHASH, bigqueryParserHAVING, bigqueryParserIF, bigqueryParserIGNORE, bigqueryParserIN, bigqueryParserINNER, bigqueryParserINTERSECT, bigqueryParserINTERVAL, bigqueryParserINTO, bigqueryParserIS, bigqueryParserJOIN, bigqueryParserLATERAL, bigqueryParserLEFT, bigqueryParserLIKE, bigqueryParserLIMIT, bigqueryParserLOOKUP, bigqueryParserMERGE, bigqueryParserNATURAL, bigqueryParserNEW, bigqueryParserNO, bigqueryParserNOT, bigqueryParserS_NULL, bigqueryParserNULLS, bigqueryParserOF, bigqueryParserOFFSET, bigqueryParserON, bigqueryParserOR, bigqueryParserORDER, bigqueryParserORDINAL, bigqueryParserOUTER, bigqueryParserOVER, bigqueryParserPARTITION, bigqueryParserPRECEDING, bigqueryParserPROTO, bigqueryParserRANGE, bigqueryParserRECURSIVE, bigqueryParserREPLACE, bigqueryParserRESPECT, bigqueryParserRIGHT, bigqueryParserROLLUP, bigqueryParserROWS, bigqueryParserSAFE_OFFSET, bigqueryParserSAFE_ORDINAL, bigqueryParserSELECT, bigqueryParserSET, bigqueryParserSOME, bigqueryParserSSTRUCT, bigqueryParserSYSTEM, bigqueryParserTABLESAMPLE, bigqueryParserTHEN, bigqueryParserTIME, bigqueryParserTO, bigqueryParserTREAT, bigqueryParserTRUE, bigqueryParserUNBOUNDED, bigqueryParserUNION, bigqueryParserUNNEST, bigqueryParserUSING, bigqueryParserWHEN, bigqueryParserWHERE, bigqueryParserWINDOW, bigqueryParserWITH, bigqueryParserWITHIN, bigqueryParserQUOTED_STRING, bigqueryParserTRIPLE_QUOTED_STRING, bigqueryParserRAW_STRING, bigqueryParserBYTE_STRING, bigqueryParserRAW_BYTE_STRING, bigqueryParserID:
			{
				p.SetState(429)
				p.expr(0)
			}
			p.SetState(434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == bigqueryParserT__4 {
				{
					p.SetState(430)
					p.Match(bigqueryParserT__4)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(431)
					p.expr(0)
				}

				p.SetState(436)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case bigqueryParserT__3:
			{
				p.SetState(437)
				p.Match(bigqueryParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(440)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		{
			p.SetState(442)
			p.Cast_expr()
		}

	case 9:
		{
			p.SetState(443)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(444)
			p.expr(0)
		}
		{
			p.SetState(445)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(447)
			p.Match(bigqueryParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(448)
			p.expr(0)
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == bigqueryParserT__4 {
			{
				p.SetState(449)
				p.Match(bigqueryParserT__4)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(450)
				p.expr(0)
			}

			p.SetState(455)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(456)
			p.Match(bigqueryParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		{
			p.SetState(458)
			p.Column_expr()
		}

	case 12:
		{
			p.SetState(459)
			p.Keyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(462)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(463)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bigqueryParserT__3 || _la == bigqueryParserT__9) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(464)
					p.expr(20)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(465)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(466)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bigqueryParserT__5 || _la == bigqueryParserT__10) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(467)
					p.expr(19)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(468)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(469)
					_la = p.GetTokenStream().LA(1)

					if !(_la == bigqueryParserT__11 || _la == bigqueryParserT__12) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(470)
					p.expr(18)
				}

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(471)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(472)
					p.Match(bigqueryParserT__13)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(473)
					p.expr(17)
				}

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(474)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(475)
					p.Match(bigqueryParserT__14)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(476)
					p.expr(16)
				}

			case 6:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(477)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(478)
					p.Match(bigqueryParserT__15)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(479)
					p.expr(15)
				}

			case 7:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(480)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				p.SetState(500)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(481)
						p.Match(bigqueryParserT__16)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(482)
						p.Match(bigqueryParserT__17)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(483)
						p.Match(bigqueryParserT__18)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 4:
					{
						p.SetState(484)
						p.Match(bigqueryParserT__19)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 5:
					{
						p.SetState(485)
						p.Match(bigqueryParserT__20)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 6:
					{
						p.SetState(486)
						p.Match(bigqueryParserT__21)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 7:
					{
						p.SetState(487)
						p.Match(bigqueryParserT__22)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 8:
					p.SetState(489)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == bigqueryParserNOT {
						{
							p.SetState(488)
							p.Match(bigqueryParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(491)
						p.Match(bigqueryParserLIKE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 9:
					p.SetState(493)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == bigqueryParserNOT {
						{
							p.SetState(492)
							p.Match(bigqueryParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(495)
						p.Match(bigqueryParserBETWEEN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(496)
						p.expr(0)
					}
					{
						p.SetState(497)
						p.Match(bigqueryParserAND)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(498)
						p.expr(0)
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(502)
					p.expr(14)
				}

			case 8:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(503)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(504)
					p.Match(bigqueryParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(505)
					p.expr(9)
				}

			case 9:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(506)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(507)
					p.Match(bigqueryParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(508)
					p.expr(8)
				}

			case 10:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(509)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(510)
					p.Match(bigqueryParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(512)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == bigqueryParserNOT {
					{
						p.SetState(511)
						p.Match(bigqueryParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(514)
					p.Match(bigqueryParserS_NULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 11:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, bigqueryParserRULE_expr)
				p.SetState(515)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				p.SetState(517)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == bigqueryParserNOT {
					{
						p.SetState(516)
						p.Match(bigqueryParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(519)
					p.Match(bigqueryParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(537)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(520)
						p.Match(bigqueryParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(521)
						p.expr(0)
					}
					p.SetState(526)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					for _la == bigqueryParserT__4 {
						{
							p.SetState(522)
							p.Match(bigqueryParserT__4)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(523)
							p.expr(0)
						}

						p.SetState(528)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)
					}
					{
						p.SetState(529)
						p.Match(bigqueryParserT__1)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(531)
						p.Query_statement()
					}

				case 3:
					{
						p.SetState(532)
						p.Match(bigqueryParserUNNEST)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(533)
						p.Match(bigqueryParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(534)
						p.Array_expr()
					}
					{
						p.SetState(535)
						p.Match(bigqueryParserT__1)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICast_exprContext is an interface to support dynamic dispatch.
type ICast_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST() antlr.TerminalNode
	Expr() IExprContext
	AS() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext

	// IsCast_exprContext differentiates from other interfaces.
	IsCast_exprContext()
}

type Cast_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_exprContext() *Cast_exprContext {
	var p = new(Cast_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_cast_expr
	return p
}

func InitEmptyCast_exprContext(p *Cast_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_cast_expr
}

func (*Cast_exprContext) IsCast_exprContext() {}

func NewCast_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_exprContext {
	var p = new(Cast_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_cast_expr

	return p
}

func (s *Cast_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_exprContext) CAST() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCAST, 0)
}

func (s *Cast_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Cast_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, 0)
}

func (s *Cast_exprContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Cast_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterCast_expr(s)
	}
}

func (s *Cast_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitCast_expr(s)
	}
}

func (s *Cast_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitCast_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Cast_expr() (localctx ICast_exprContext) {
	localctx = NewCast_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, bigqueryParserRULE_cast_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(bigqueryParserCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(545)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(546)
		p.expr(0)
	}
	{
		p.SetState(547)
		p.Match(bigqueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(548)
		p.Datatype_name()
	}
	{
		p.SetState(549)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_exprContext is an interface to support dynamic dispatch.
type IColumn_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_expr() IColumn_exprContext
	Column_name() IColumn_nameContext
	Table_name() ITable_nameContext
	Dataset_name() IDataset_nameContext
	Project_name() IProject_nameContext

	// IsColumn_exprContext differentiates from other interfaces.
	IsColumn_exprContext()
}

type Column_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_exprContext() *Column_exprContext {
	var p = new(Column_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_column_expr
	return p
}

func InitEmptyColumn_exprContext(p *Column_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_column_expr
}

func (*Column_exprContext) IsColumn_exprContext() {}

func NewColumn_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_exprContext {
	var p = new(Column_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_column_expr

	return p
}

func (s *Column_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_exprContext) Column_expr() IColumn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_exprContext)
}

func (s *Column_exprContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_exprContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Column_exprContext) Dataset_name() IDataset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataset_nameContext)
}

func (s *Column_exprContext) Project_name() IProject_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProject_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProject_nameContext)
}

func (s *Column_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterColumn_expr(s)
	}
}

func (s *Column_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitColumn_expr(s)
	}
}

func (s *Column_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitColumn_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Column_expr() (localctx IColumn_exprContext) {
	localctx = NewColumn_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, bigqueryParserRULE_column_expr)
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(551)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Column_expr()
		}
		{
			p.SetState(553)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(568)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			p.SetState(563)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
				p.SetState(558)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(555)
						p.Project_name()
					}
					{
						p.SetState(556)
						p.Match(bigqueryParserT__2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(560)
					p.Dataset_name()
				}
				{
					p.SetState(561)
					p.Match(bigqueryParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(565)
				p.Table_name()
			}
			{
				p.SetState(566)
				p.Match(bigqueryParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(570)
			p.Column_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcept_statementContext is an interface to support dynamic dispatch.
type IExcept_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext

	// IsExcept_statementContext differentiates from other interfaces.
	IsExcept_statementContext()
}

type Except_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_statementContext() *Except_statementContext {
	var p = new(Except_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_except_statement
	return p
}

func InitEmptyExcept_statementContext(p *Except_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_except_statement
}

func (*Except_statementContext) IsExcept_statementContext() {}

func NewExcept_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_statementContext {
	var p = new(Except_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_except_statement

	return p
}

func (s *Except_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_statementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXCEPT, 0)
}

func (s *Except_statementContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Except_statementContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Except_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterExcept_statement(s)
	}
}

func (s *Except_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitExcept_statement(s)
	}
}

func (s *Except_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitExcept_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Except_statement() (localctx IExcept_statementContext) {
	localctx = NewExcept_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, bigqueryParserRULE_except_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Match(bigqueryParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(574)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Column_name()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bigqueryParserT__4 {
		{
			p.SetState(576)
			p.Match(bigqueryParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.Column_name()
		}

		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(583)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplace_statementContext is an interface to support dynamic dispatch.
type IReplace_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllAlias_name() []IAlias_nameContext
	Alias_name(i int) IAlias_nameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode

	// IsReplace_statementContext differentiates from other interfaces.
	IsReplace_statementContext()
}

type Replace_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_statementContext() *Replace_statementContext {
	var p = new(Replace_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_replace_statement
	return p
}

func InitEmptyReplace_statementContext(p *Replace_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_replace_statement
}

func (*Replace_statementContext) IsReplace_statementContext() {}

func NewReplace_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_statementContext {
	var p = new(Replace_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_replace_statement

	return p
}

func (s *Replace_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_statementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserREPLACE, 0)
}

func (s *Replace_statementContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Replace_statementContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Replace_statementContext) AllAlias_name() []IAlias_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlias_nameContext); ok {
			len++
		}
	}

	tst := make([]IAlias_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlias_nameContext); ok {
			tst[i] = t.(IAlias_nameContext)
			i++
		}
	}

	return tst
}

func (s *Replace_statementContext) Alias_name(i int) IAlias_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlias_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlias_nameContext)
}

func (s *Replace_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserAS)
}

func (s *Replace_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, i)
}

func (s *Replace_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replace_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterReplace_statement(s)
	}
}

func (s *Replace_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitReplace_statement(s)
	}
}

func (s *Replace_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitReplace_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Replace_statement() (localctx IReplace_statementContext) {
	localctx = NewReplace_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, bigqueryParserRULE_replace_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Match(bigqueryParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(586)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(587)
		p.expr(0)
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35181821954) != 0) || _la == bigqueryParserID {
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserAS {
			{
				p.SetState(588)
				p.Match(bigqueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(591)
			p.Alias_name()
		}

	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bigqueryParserT__4 {
		{
			p.SetState(594)
			p.Match(bigqueryParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.expr(0)
		}

		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserAS {
			{
				p.SetState(596)
				p.Match(bigqueryParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(599)
			p.Alias_name()
		}

		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(606)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_typeContext is an interface to support dynamic dispatch.
type IJoin_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsJoin_typeContext differentiates from other interfaces.
	IsJoin_typeContext()
}

type Join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_typeContext() *Join_typeContext {
	var p = new(Join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_join_type
	return p
}

func InitEmptyJoin_typeContext(p *Join_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_join_type
}

func (*Join_typeContext) IsJoin_typeContext() {}

func NewJoin_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_typeContext {
	var p = new(Join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_join_type

	return p
}

func (s *Join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_typeContext) INNER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINNER, 0)
}

func (s *Join_typeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCROSS, 0)
}

func (s *Join_typeContext) FULL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFULL, 0)
}

func (s *Join_typeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOUTER, 0)
}

func (s *Join_typeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLEFT, 0)
}

func (s *Join_typeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRIGHT, 0)
}

func (s *Join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterJoin_type(s)
	}
}

func (s *Join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitJoin_type(s)
	}
}

func (s *Join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitJoin_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Join_type() (localctx IJoin_typeContext) {
	localctx = NewJoin_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, bigqueryParserRULE_join_type)
	var _la int

	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserINNER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.Match(bigqueryParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserCROSS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(609)
			p.Match(bigqueryParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserFULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(610)
			p.Match(bigqueryParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserOUTER {
			{
				p.SetState(611)
				p.Match(bigqueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case bigqueryParserLEFT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(614)
			p.Match(bigqueryParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserOUTER {
			{
				p.SetState(615)
				p.Match(bigqueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case bigqueryParserRIGHT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(618)
			p.Match(bigqueryParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserOUTER {
			{
				p.SetState(619)
				p.Match(bigqueryParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOn_clauseContext is an interface to support dynamic dispatch.
type IOn_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Bool_expression() IBool_expressionContext

	// IsOn_clauseContext differentiates from other interfaces.
	IsOn_clauseContext()
}

type On_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_clauseContext() *On_clauseContext {
	var p = new(On_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_on_clause
	return p
}

func InitEmptyOn_clauseContext(p *On_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_on_clause
}

func (*On_clauseContext) IsOn_clauseContext() {}

func NewOn_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_clauseContext {
	var p = new(On_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_on_clause

	return p
}

func (s *On_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *On_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(bigqueryParserON, 0)
}

func (s *On_clauseContext) Bool_expression() IBool_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expressionContext)
}

func (s *On_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *On_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterOn_clause(s)
	}
}

func (s *On_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitOn_clause(s)
	}
}

func (s *On_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitOn_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) On_clause() (localctx IOn_clauseContext) {
	localctx = NewOn_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, bigqueryParserRULE_on_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.Match(bigqueryParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(625)
		p.Bool_expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_opContext is an interface to support dynamic dispatch.
type ISet_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsSet_opContext differentiates from other interfaces.
	IsSet_opContext()
}

type Set_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_opContext() *Set_opContext {
	var p = new(Set_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_set_op
	return p
}

func InitEmptySet_opContext(p *Set_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_set_op
}

func (*Set_opContext) IsSet_opContext() {}

func NewSet_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_opContext {
	var p = new(Set_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_set_op

	return p
}

func (s *Set_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_opContext) UNION() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNION, 0)
}

func (s *Set_opContext) ALL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserALL, 0)
}

func (s *Set_opContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDISTINCT, 0)
}

func (s *Set_opContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINTERSECT, 0)
}

func (s *Set_opContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXCEPT, 0)
}

func (s *Set_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterSet_op(s)
	}
}

func (s *Set_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitSet_op(s)
	}
}

func (s *Set_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitSet_op(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Set_op() (localctx ISet_opContext) {
	localctx = NewSet_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, bigqueryParserRULE_set_op)
	var _la int

	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.Match(bigqueryParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == bigqueryParserALL || _la == bigqueryParserDISTINCT {
			{
				p.SetState(628)
				_la = p.GetTokenStream().LA(1)

				if !(_la == bigqueryParserALL || _la == bigqueryParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case bigqueryParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(631)
			p.Match(bigqueryParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(632)
			p.Match(bigqueryParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserEXCEPT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.Match(bigqueryParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(634)
			p.Match(bigqueryParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	AllJoin_name() []IJoin_nameContext
	Join_name(i int) IJoin_nameContext

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) USING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUSING, 0)
}

func (s *Using_clauseContext) AllJoin_name() []IJoin_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoin_nameContext); ok {
			len++
		}
	}

	tst := make([]IJoin_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoin_nameContext); ok {
			tst[i] = t.(IJoin_nameContext)
			i++
		}
	}

	return tst
}

func (s *Using_clauseContext) Join_name(i int) IJoin_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_nameContext)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (s *Using_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitUsing_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, bigqueryParserRULE_using_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(bigqueryParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(638)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(639)
		p.Join_name()
	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bigqueryParserT__4 {
		{
			p.SetState(640)
			p.Match(bigqueryParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(641)
			p.Join_name()
		}

		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(647)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_pathContext is an interface to support dynamic dispatch.
type IField_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsField_pathContext differentiates from other interfaces.
	IsField_pathContext()
}

type Field_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_pathContext() *Field_pathContext {
	var p = new(Field_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_field_path
	return p
}

func InitEmptyField_pathContext(p *Field_pathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_field_path
}

func (*Field_pathContext) IsField_pathContext() {}

func NewField_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_pathContext {
	var p = new(Field_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_field_path

	return p
}

func (s *Field_pathContext) GetParser() antlr.Parser { return s.parser }
func (s *Field_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterField_path(s)
	}
}

func (s *Field_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitField_path(s)
	}
}

func (s *Field_pathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitField_path(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Field_path() (localctx IField_pathContext) {
	localctx = NewField_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, bigqueryParserRULE_field_path)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISstructContext is an interface to support dynamic dispatch.
type ISstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSTRUCT() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext

	// IsSstructContext differentiates from other interfaces.
	IsSstructContext()
}

type SstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySstructContext() *SstructContext {
	var p = new(SstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_sstruct
	return p
}

func InitEmptySstructContext(p *SstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_sstruct
}

func (*SstructContext) IsSstructContext() {}

func NewSstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SstructContext {
	var p = new(SstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_sstruct

	return p
}

func (s *SstructContext) GetParser() antlr.Parser { return s.parser }

func (s *SstructContext) SSTRUCT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSSTRUCT, 0)
}

func (s *SstructContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *SstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterSstruct(s)
	}
}

func (s *SstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitSstruct(s)
	}
}

func (s *SstructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitSstruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Sstruct() (localctx ISstructContext) {
	localctx = NewSstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, bigqueryParserRULE_sstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(bigqueryParserSSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Match(bigqueryParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Datatype_name()
	}
	{
		p.SetState(654)
		p.Match(bigqueryParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_exprContext is an interface to support dynamic dispatch.
type IArray_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	Datatype_name() IDatatype_nameContext

	// IsArray_exprContext differentiates from other interfaces.
	IsArray_exprContext()
}

type Array_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_exprContext() *Array_exprContext {
	var p = new(Array_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_expr
	return p
}

func InitEmptyArray_exprContext(p *Array_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_expr
}

func (*Array_exprContext) IsArray_exprContext() {}

func NewArray_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_exprContext {
	var p = new(Array_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_array_expr

	return p
}

func (s *Array_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_exprContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserARRAY, 0)
}

func (s *Array_exprContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Array_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterArray_expr(s)
	}
}

func (s *Array_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitArray_expr(s)
	}
}

func (s *Array_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitArray_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Array_expr() (localctx IArray_exprContext) {
	localctx = NewArray_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, bigqueryParserRULE_array_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(bigqueryParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Match(bigqueryParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Datatype_name()
	}
	{
		p.SetState(659)
		p.Match(bigqueryParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_pathContext is an interface to support dynamic dispatch.
type IArray_pathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArray_pathContext differentiates from other interfaces.
	IsArray_pathContext()
}

type Array_pathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_pathContext() *Array_pathContext {
	var p = new(Array_pathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_path
	return p
}

func InitEmptyArray_pathContext(p *Array_pathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_path
}

func (*Array_pathContext) IsArray_pathContext() {}

func NewArray_pathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_pathContext {
	var p = new(Array_pathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_array_path

	return p
}

func (s *Array_pathContext) GetParser() antlr.Parser { return s.parser }
func (s *Array_pathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_pathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_pathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterArray_path(s)
	}
}

func (s *Array_pathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitArray_path(s)
	}
}

func (s *Array_pathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitArray_path(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Array_path() (localctx IArray_pathContext) {
	localctx = NewArray_pathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, bigqueryParserRULE_array_path)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expressionContext is an interface to support dynamic dispatch.
type IBool_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsBool_expressionContext differentiates from other interfaces.
	IsBool_expressionContext()
}

type Bool_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expressionContext() *Bool_expressionContext {
	var p = new(Bool_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_bool_expression
	return p
}

func InitEmptyBool_expressionContext(p *Bool_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_bool_expression
}

func (*Bool_expressionContext) IsBool_expressionContext() {}

func NewBool_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expressionContext {
	var p = new(Bool_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_bool_expression

	return p
}

func (s *Bool_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterBool_expression(s)
	}
}

func (s *Bool_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitBool_expression(s)
	}
}

func (s *Bool_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitBool_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Bool_expression() (localctx IBool_expressionContext) {
	localctx = NewBool_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, bigqueryParserRULE_bool_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_nameContext is an interface to support dynamic dispatch.
type IWindow_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindow_nameContext differentiates from other interfaces.
	IsWindow_nameContext()
}

type Window_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_nameContext() *Window_nameContext {
	var p = new(Window_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_name
	return p
}

func InitEmptyWindow_nameContext(p *Window_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_name
}

func (*Window_nameContext) IsWindow_nameContext() {}

func NewWindow_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_nameContext {
	var p = new(Window_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_window_name

	return p
}

func (s *Window_nameContext) GetParser() antlr.Parser { return s.parser }
func (s *Window_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterWindow_name(s)
	}
}

func (s *Window_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitWindow_name(s)
	}
}

func (s *Window_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitWindow_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Window_name() (localctx IWindow_nameContext) {
	localctx = NewWindow_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, bigqueryParserRULE_window_name)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_definitionContext is an interface to support dynamic dispatch.
type IWindow_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindow_definitionContext differentiates from other interfaces.
	IsWindow_definitionContext()
}

type Window_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_definitionContext() *Window_definitionContext {
	var p = new(Window_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_definition
	return p
}

func InitEmptyWindow_definitionContext(p *Window_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_window_definition
}

func (*Window_definitionContext) IsWindow_definitionContext() {}

func NewWindow_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_definitionContext {
	var p = new(Window_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_window_definition

	return p
}

func (s *Window_definitionContext) GetParser() antlr.Parser { return s.parser }
func (s *Window_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterWindow_definition(s)
	}
}

func (s *Window_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitWindow_definition(s)
	}
}

func (s *Window_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitWindow_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Window_definition() (localctx IWindow_definitionContext) {
	localctx = NewWindow_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, bigqueryParserRULE_window_definition)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountContext is an interface to support dynamic dispatch.
type ICountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsCountContext differentiates from other interfaces.
	IsCountContext()
}

type CountContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountContext() *CountContext {
	var p = new(CountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_count
	return p
}

func InitEmptyCountContext(p *CountContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_count
}

func (*CountContext) IsCountContext() {}

func NewCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountContext {
	var p = new(CountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_count

	return p
}

func (s *CountContext) GetParser() antlr.Parser { return s.parser }

func (s *CountContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterCount(s)
	}
}

func (s *CountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitCount(s)
	}
}

func (s *CountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Count() (localctx ICountContext) {
	localctx = NewCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, bigqueryParserRULE_count)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkip_rowsContext is an interface to support dynamic dispatch.
type ISkip_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSkip_rowsContext differentiates from other interfaces.
	IsSkip_rowsContext()
}

type Skip_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkip_rowsContext() *Skip_rowsContext {
	var p = new(Skip_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_skip_rows
	return p
}

func InitEmptySkip_rowsContext(p *Skip_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_skip_rows
}

func (*Skip_rowsContext) IsSkip_rowsContext() {}

func NewSkip_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Skip_rowsContext {
	var p = new(Skip_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_skip_rows

	return p
}

func (s *Skip_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Skip_rowsContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Skip_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Skip_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Skip_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterSkip_rows(s)
	}
}

func (s *Skip_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitSkip_rows(s)
	}
}

func (s *Skip_rowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitSkip_rows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Skip_rows() (localctx ISkip_rowsContext) {
	localctx = NewSkip_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, bigqueryParserRULE_skip_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_statementContext is an interface to support dynamic dispatch.
type IWith_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCte_name() []ICte_nameContext
	Cte_name(i int) ICte_nameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllQuery_expr() []IQuery_exprContext
	Query_expr(i int) IQuery_exprContext

	// IsWith_statementContext differentiates from other interfaces.
	IsWith_statementContext()
}

type With_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_statementContext() *With_statementContext {
	var p = new(With_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_with_statement
	return p
}

func InitEmptyWith_statementContext(p *With_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_with_statement
}

func (*With_statementContext) IsWith_statementContext() {}

func NewWith_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_statementContext {
	var p = new(With_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_with_statement

	return p
}

func (s *With_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *With_statementContext) WITH() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWITH, 0)
}

func (s *With_statementContext) AllCte_name() []ICte_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICte_nameContext); ok {
			len++
		}
	}

	tst := make([]ICte_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICte_nameContext); ok {
			tst[i] = t.(ICte_nameContext)
			i++
		}
	}

	return tst
}

func (s *With_statementContext) Cte_name(i int) ICte_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_nameContext)
}

func (s *With_statementContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserAS)
}

func (s *With_statementContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, i)
}

func (s *With_statementContext) AllQuery_expr() []IQuery_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_exprContext); ok {
			len++
		}
	}

	tst := make([]IQuery_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_exprContext); ok {
			tst[i] = t.(IQuery_exprContext)
			i++
		}
	}

	return tst
}

func (s *With_statementContext) Query_expr(i int) IQuery_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_exprContext)
}

func (s *With_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterWith_statement(s)
	}
}

func (s *With_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitWith_statement(s)
	}
}

func (s *With_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitWith_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) With_statement() (localctx IWith_statementContext) {
	localctx = NewWith_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, bigqueryParserRULE_with_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Match(bigqueryParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(674)
		p.Cte_name()
	}
	{
		p.SetState(675)
		p.Match(bigqueryParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(676)
		p.Match(bigqueryParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(677)
		p.query_expr(0)
	}
	{
		p.SetState(678)
		p.Match(bigqueryParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == bigqueryParserT__4 {
		{
			p.SetState(679)
			p.Match(bigqueryParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)
			p.Cte_name()
		}
		{
			p.SetState(681)
			p.Match(bigqueryParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.query_expr(0)
		}
		{
			p.SetState(684)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	AllDQOUTE() []antlr.TerminalNode
	DQOUTE(i int) antlr.TerminalNode
	Name() INameContext
	AllQUOTE() []antlr.TerminalNode
	QUOTE(i int) antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) ID() antlr.TerminalNode {
	return s.GetToken(bigqueryParserID, 0)
}

func (s *NameContext) AllDQOUTE() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserDQOUTE)
}

func (s *NameContext) DQOUTE(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserDQOUTE, i)
}

func (s *NameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *NameContext) AllQUOTE() []antlr.TerminalNode {
	return s.GetTokens(bigqueryParserQUOTE)
}

func (s *NameContext) QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(bigqueryParserQUOTE, i)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, bigqueryParserRULE_name)
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(691)
			p.Match(bigqueryParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserDQOUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(692)
			p.Match(bigqueryParserDQOUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)
			p.Name()
		}
		{
			p.SetState(694)
			p.Match(bigqueryParserDQOUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserT__0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(696)
			p.Match(bigqueryParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(697)
			p.Name()
		}
		{
			p.SetState(698)
			p.Match(bigqueryParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserT__23:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(700)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(701)
			p.Name()
		}
		{
			p.SetState(702)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case bigqueryParserQUOTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(704)
			p.Match(bigqueryParserQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(705)
			p.Name()
		}
		{
			p.SetState(706)
			p.Match(bigqueryParserQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlias_nameContext is an interface to support dynamic dispatch.
type IAlias_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsAlias_nameContext differentiates from other interfaces.
	IsAlias_nameContext()
}

type Alias_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_nameContext() *Alias_nameContext {
	var p = new(Alias_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_alias_name
	return p
}

func InitEmptyAlias_nameContext(p *Alias_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_alias_name
}

func (*Alias_nameContext) IsAlias_nameContext() {}

func NewAlias_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_nameContext {
	var p = new(Alias_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_alias_name

	return p
}

func (s *Alias_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Alias_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterAlias_name(s)
	}
}

func (s *Alias_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitAlias_name(s)
	}
}

func (s *Alias_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitAlias_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Alias_name() (localctx IAlias_nameContext) {
	localctx = NewAlias_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, bigqueryParserRULE_alias_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArray_nameContext is an interface to support dynamic dispatch.
type IArray_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsArray_nameContext differentiates from other interfaces.
	IsArray_nameContext()
}

type Array_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_nameContext() *Array_nameContext {
	var p = new(Array_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_name
	return p
}

func InitEmptyArray_nameContext(p *Array_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_array_name
}

func (*Array_nameContext) IsArray_nameContext() {}

func NewArray_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_nameContext {
	var p = new(Array_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_array_name

	return p
}

func (s *Array_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Array_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterArray_name(s)
	}
}

func (s *Array_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitArray_name(s)
	}
}

func (s *Array_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitArray_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Array_name() (localctx IArray_nameContext) {
	localctx = NewArray_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, bigqueryParserRULE_array_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (s *Column_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitColumn_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, bigqueryParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_nameContext is an interface to support dynamic dispatch.
type ICte_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsCte_nameContext differentiates from other interfaces.
	IsCte_nameContext()
}

type Cte_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_nameContext() *Cte_nameContext {
	var p = new(Cte_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_cte_name
	return p
}

func InitEmptyCte_nameContext(p *Cte_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_cte_name
}

func (*Cte_nameContext) IsCte_nameContext() {}

func NewCte_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_nameContext {
	var p = new(Cte_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_cte_name

	return p
}

func (s *Cte_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Cte_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterCte_name(s)
	}
}

func (s *Cte_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitCte_name(s)
	}
}

func (s *Cte_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitCte_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Cte_name() (localctx ICte_nameContext) {
	localctx = NewCte_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, bigqueryParserRULE_cte_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataset_nameContext is an interface to support dynamic dispatch.
type IDataset_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsDataset_nameContext differentiates from other interfaces.
	IsDataset_nameContext()
}

type Dataset_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataset_nameContext() *Dataset_nameContext {
	var p = new(Dataset_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_dataset_name
	return p
}

func InitEmptyDataset_nameContext(p *Dataset_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_dataset_name
}

func (*Dataset_nameContext) IsDataset_nameContext() {}

func NewDataset_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dataset_nameContext {
	var p = new(Dataset_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_dataset_name

	return p
}

func (s *Dataset_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dataset_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dataset_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dataset_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dataset_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterDataset_name(s)
	}
}

func (s *Dataset_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitDataset_name(s)
	}
}

func (s *Dataset_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitDataset_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Dataset_name() (localctx IDataset_nameContext) {
	localctx = NewDataset_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, bigqueryParserRULE_dataset_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatype_nameContext is an interface to support dynamic dispatch.
type IDatatype_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsDatatype_nameContext differentiates from other interfaces.
	IsDatatype_nameContext()
}

type Datatype_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_nameContext() *Datatype_nameContext {
	var p = new(Datatype_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_datatype_name
	return p
}

func InitEmptyDatatype_nameContext(p *Datatype_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_datatype_name
}

func (*Datatype_nameContext) IsDatatype_nameContext() {}

func NewDatatype_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_nameContext {
	var p = new(Datatype_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_datatype_name

	return p
}

func (s *Datatype_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Datatype_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterDatatype_name(s)
	}
}

func (s *Datatype_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitDatatype_name(s)
	}
}

func (s *Datatype_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitDatatype_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Datatype_name() (localctx IDatatype_nameContext) {
	localctx = NewDatatype_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, bigqueryParserRULE_datatype_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_function_name
	return p
}

func InitEmptyFunction_nameContext(p *Function_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_function_name
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (s *Function_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitFunction_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Function_name() (localctx IFunction_nameContext) {
	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, bigqueryParserRULE_function_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_nameContext is an interface to support dynamic dispatch.
type IJoin_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsJoin_nameContext differentiates from other interfaces.
	IsJoin_nameContext()
}

type Join_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_nameContext() *Join_nameContext {
	var p = new(Join_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_join_name
	return p
}

func InitEmptyJoin_nameContext(p *Join_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_join_name
}

func (*Join_nameContext) IsJoin_nameContext() {}

func NewJoin_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_nameContext {
	var p = new(Join_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_join_name

	return p
}

func (s *Join_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Join_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterJoin_name(s)
	}
}

func (s *Join_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitJoin_name(s)
	}
}

func (s *Join_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitJoin_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Join_name() (localctx IJoin_nameContext) {
	localctx = NewJoin_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, bigqueryParserRULE_join_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMember_nameContext is an interface to support dynamic dispatch.
type IMember_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsMember_nameContext differentiates from other interfaces.
	IsMember_nameContext()
}

type Member_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_nameContext() *Member_nameContext {
	var p = new(Member_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_member_name
	return p
}

func InitEmptyMember_nameContext(p *Member_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_member_name
}

func (*Member_nameContext) IsMember_nameContext() {}

func NewMember_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_nameContext {
	var p = new(Member_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_member_name

	return p
}

func (s *Member_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Member_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterMember_name(s)
	}
}

func (s *Member_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitMember_name(s)
	}
}

func (s *Member_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitMember_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Member_name() (localctx IMember_nameContext) {
	localctx = NewMember_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, bigqueryParserRULE_member_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProject_nameContext is an interface to support dynamic dispatch.
type IProject_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsProject_nameContext differentiates from other interfaces.
	IsProject_nameContext()
}

type Project_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProject_nameContext() *Project_nameContext {
	var p = new(Project_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_project_name
	return p
}

func InitEmptyProject_nameContext(p *Project_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_project_name
}

func (*Project_nameContext) IsProject_nameContext() {}

func NewProject_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Project_nameContext {
	var p = new(Project_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_project_name

	return p
}

func (s *Project_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Project_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Project_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Project_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Project_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterProject_name(s)
	}
}

func (s *Project_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitProject_name(s)
	}
}

func (s *Project_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitProject_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Project_name() (localctx IProject_nameContext) {
	localctx = NewProject_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, bigqueryParserRULE_project_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_nameContext is an interface to support dynamic dispatch.
type IStruct_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsStruct_nameContext differentiates from other interfaces.
	IsStruct_nameContext()
}

type Struct_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_nameContext() *Struct_nameContext {
	var p = new(Struct_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_struct_name
	return p
}

func InitEmptyStruct_nameContext(p *Struct_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_struct_name
}

func (*Struct_nameContext) IsStruct_nameContext() {}

func NewStruct_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_nameContext {
	var p = new(Struct_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_struct_name

	return p
}

func (s *Struct_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Struct_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterStruct_name(s)
	}
}

func (s *Struct_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitStruct_name(s)
	}
}

func (s *Struct_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitStruct_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Struct_name() (localctx IStruct_nameContext) {
	localctx = NewStruct_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, bigqueryParserRULE_struct_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitTable_name(s)
	}
}

func (s *Table_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitTable_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, bigqueryParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_exprContext is an interface to support dynamic dispatch.
type ITable_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	Dataset_name() IDataset_nameContext
	Project_name() IProject_nameContext
	Table_expr() ITable_exprContext

	// IsTable_exprContext differentiates from other interfaces.
	IsTable_exprContext()
}

type Table_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_exprContext() *Table_exprContext {
	var p = new(Table_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_table_expr
	return p
}

func InitEmptyTable_exprContext(p *Table_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_table_expr
}

func (*Table_exprContext) IsTable_exprContext() {}

func NewTable_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_exprContext {
	var p = new(Table_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_table_expr

	return p
}

func (s *Table_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_exprContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Table_exprContext) Dataset_name() IDataset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataset_nameContext)
}

func (s *Table_exprContext) Project_name() IProject_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProject_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProject_nameContext)
}

func (s *Table_exprContext) Table_expr() ITable_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_exprContext)
}

func (s *Table_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterTable_expr(s)
	}
}

func (s *Table_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitTable_expr(s)
	}
}

func (s *Table_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitTable_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Table_expr() (localctx ITable_exprContext) {
	localctx = NewTable_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, bigqueryParserRULE_table_expr)
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(742)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			p.SetState(737)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(734)
					p.Project_name()
				}
				{
					p.SetState(735)
					p.Match(bigqueryParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(739)
				p.Dataset_name()
			}
			{
				p.SetState(740)
				p.Match(bigqueryParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(744)
			p.Table_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Table_expr()
		}
		{
			p.SetState(747)
			p.Match(bigqueryParserT__23)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer_type() IInteger_typeContext
	Float_type() IFloat_typeContext

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer_type() IInteger_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *NumberContext) Float_type() IFloat_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_typeContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, bigqueryParserRULE_number)
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.Integer_type()
		}

	case bigqueryParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Float_type()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_integer_type
	return p
}

func InitEmptyInteger_typeContext(p *Integer_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_integer_type
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) INT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINT, 0)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (s *Integer_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitInteger_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Integer_type() (localctx IInteger_typeContext) {
	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, bigqueryParserRULE_integer_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(bigqueryParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloat_typeContext is an interface to support dynamic dispatch.
type IFloat_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode

	// IsFloat_typeContext differentiates from other interfaces.
	IsFloat_typeContext()
}

type Float_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_typeContext() *Float_typeContext {
	var p = new(Float_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_float_type
	return p
}

func InitEmptyFloat_typeContext(p *Float_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_float_type
}

func (*Float_typeContext) IsFloat_typeContext() {}

func NewFloat_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_typeContext {
	var p = new(Float_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_float_type

	return p
}

func (s *Float_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_typeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFLOAT, 0)
}

func (s *Float_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterFloat_type(s)
	}
}

func (s *Float_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitFloat_type(s)
	}
}

func (s *Float_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitFloat_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Float_type() (localctx IFloat_typeContext) {
	localctx = NewFloat_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, bigqueryParserRULE_float_type)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(bigqueryParserFLOAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Quoted_string() IQuoted_stringContext
	Triple_quoted_string() ITriple_quoted_stringContext
	Raw_string() IRaw_stringContext
	Byte_string() IByte_stringContext
	Raw_byte_string() IRaw_byte_stringContext
	Special_string() ISpecial_stringContext

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) Quoted_string() IQuoted_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuoted_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *StringContext) Triple_quoted_string() ITriple_quoted_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriple_quoted_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriple_quoted_stringContext)
}

func (s *StringContext) Raw_string() IRaw_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaw_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaw_stringContext)
}

func (s *StringContext) Byte_string() IByte_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IByte_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IByte_stringContext)
}

func (s *StringContext) Raw_byte_string() IRaw_byte_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaw_byte_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaw_byte_stringContext)
}

func (s *StringContext) Special_string() ISpecial_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecial_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecial_stringContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, bigqueryParserRULE_string)
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case bigqueryParserQUOTED_STRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)
			p.Quoted_string()
		}

	case bigqueryParserTRIPLE_QUOTED_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(760)
			p.Triple_quoted_string()
		}

	case bigqueryParserRAW_STRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(761)
			p.Raw_string()
		}

	case bigqueryParserBYTE_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(762)
			p.Byte_string()
		}

	case bigqueryParserRAW_BYTE_STRING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(763)
			p.Raw_byte_string()
		}

	case bigqueryParserT__0, bigqueryParserT__23, bigqueryParserQUOTE, bigqueryParserDQOUTE, bigqueryParserID:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(764)
			p.Special_string()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTED_STRING() antlr.TerminalNode

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_quoted_string
	return p
}

func InitEmptyQuoted_stringContext(p *Quoted_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_quoted_string
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserQUOTED_STRING, 0)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (s *Quoted_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitQuoted_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, bigqueryParserRULE_quoted_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(bigqueryParserQUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriple_quoted_stringContext is an interface to support dynamic dispatch.
type ITriple_quoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_QUOTED_STRING() antlr.TerminalNode

	// IsTriple_quoted_stringContext differentiates from other interfaces.
	IsTriple_quoted_stringContext()
}

type Triple_quoted_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriple_quoted_stringContext() *Triple_quoted_stringContext {
	var p = new(Triple_quoted_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_triple_quoted_string
	return p
}

func InitEmptyTriple_quoted_stringContext(p *Triple_quoted_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_triple_quoted_string
}

func (*Triple_quoted_stringContext) IsTriple_quoted_stringContext() {}

func NewTriple_quoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Triple_quoted_stringContext {
	var p = new(Triple_quoted_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_triple_quoted_string

	return p
}

func (s *Triple_quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Triple_quoted_stringContext) TRIPLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTRIPLE_QUOTED_STRING, 0)
}

func (s *Triple_quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Triple_quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Triple_quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterTriple_quoted_string(s)
	}
}

func (s *Triple_quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitTriple_quoted_string(s)
	}
}

func (s *Triple_quoted_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitTriple_quoted_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Triple_quoted_string() (localctx ITriple_quoted_stringContext) {
	localctx = NewTriple_quoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, bigqueryParserRULE_triple_quoted_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(bigqueryParserTRIPLE_QUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaw_stringContext is an interface to support dynamic dispatch.
type IRaw_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_STRING() antlr.TerminalNode

	// IsRaw_stringContext differentiates from other interfaces.
	IsRaw_stringContext()
}

type Raw_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaw_stringContext() *Raw_stringContext {
	var p = new(Raw_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_raw_string
	return p
}

func InitEmptyRaw_stringContext(p *Raw_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_raw_string
}

func (*Raw_stringContext) IsRaw_stringContext() {}

func NewRaw_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raw_stringContext {
	var p = new(Raw_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_raw_string

	return p
}

func (s *Raw_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Raw_stringContext) RAW_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRAW_STRING, 0)
}

func (s *Raw_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raw_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raw_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterRaw_string(s)
	}
}

func (s *Raw_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitRaw_string(s)
	}
}

func (s *Raw_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitRaw_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Raw_string() (localctx IRaw_stringContext) {
	localctx = NewRaw_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, bigqueryParserRULE_raw_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(bigqueryParserRAW_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IByte_stringContext is an interface to support dynamic dispatch.
type IByte_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTE_STRING() antlr.TerminalNode

	// IsByte_stringContext differentiates from other interfaces.
	IsByte_stringContext()
}

type Byte_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyByte_stringContext() *Byte_stringContext {
	var p = new(Byte_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_byte_string
	return p
}

func InitEmptyByte_stringContext(p *Byte_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_byte_string
}

func (*Byte_stringContext) IsByte_stringContext() {}

func NewByte_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Byte_stringContext {
	var p = new(Byte_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_byte_string

	return p
}

func (s *Byte_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Byte_stringContext) BYTE_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBYTE_STRING, 0)
}

func (s *Byte_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Byte_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Byte_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterByte_string(s)
	}
}

func (s *Byte_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitByte_string(s)
	}
}

func (s *Byte_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitByte_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Byte_string() (localctx IByte_stringContext) {
	localctx = NewByte_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, bigqueryParserRULE_byte_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Match(bigqueryParserBYTE_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaw_byte_stringContext is an interface to support dynamic dispatch.
type IRaw_byte_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_BYTE_STRING() antlr.TerminalNode

	// IsRaw_byte_stringContext differentiates from other interfaces.
	IsRaw_byte_stringContext()
}

type Raw_byte_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaw_byte_stringContext() *Raw_byte_stringContext {
	var p = new(Raw_byte_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_raw_byte_string
	return p
}

func InitEmptyRaw_byte_stringContext(p *Raw_byte_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_raw_byte_string
}

func (*Raw_byte_stringContext) IsRaw_byte_stringContext() {}

func NewRaw_byte_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raw_byte_stringContext {
	var p = new(Raw_byte_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_raw_byte_string

	return p
}

func (s *Raw_byte_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Raw_byte_stringContext) RAW_BYTE_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRAW_BYTE_STRING, 0)
}

func (s *Raw_byte_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raw_byte_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raw_byte_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterRaw_byte_string(s)
	}
}

func (s *Raw_byte_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitRaw_byte_string(s)
	}
}

func (s *Raw_byte_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitRaw_byte_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Raw_byte_string() (localctx IRaw_byte_stringContext) {
	localctx = NewRaw_byte_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, bigqueryParserRULE_raw_byte_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(bigqueryParserRAW_BYTE_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecial_stringContext is an interface to support dynamic dispatch.
type ISpecial_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Datatype_name() IDatatype_nameContext
	QUOTED_STRING() antlr.TerminalNode

	// IsSpecial_stringContext differentiates from other interfaces.
	IsSpecial_stringContext()
}

type Special_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecial_stringContext() *Special_stringContext {
	var p = new(Special_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_special_string
	return p
}

func InitEmptySpecial_stringContext(p *Special_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_special_string
}

func (*Special_stringContext) IsSpecial_stringContext() {}

func NewSpecial_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Special_stringContext {
	var p = new(Special_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_special_string

	return p
}

func (s *Special_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Special_stringContext) Datatype_name() IDatatype_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_nameContext)
}

func (s *Special_stringContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserQUOTED_STRING, 0)
}

func (s *Special_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Special_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Special_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterSpecial_string(s)
	}
}

func (s *Special_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitSpecial_string(s)
	}
}

func (s *Special_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitSpecial_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Special_string() (localctx ISpecial_stringContext) {
	localctx = NewSpecial_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, bigqueryParserRULE_special_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Datatype_name()
	}
	{
		p.SetState(778)
		p.Match(bigqueryParserQUOTED_STRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	ASSERT_ROWS_MODIFIED() antlr.TerminalNode
	AT() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BY() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	IF() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LOOKUP() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOT() antlr.TerminalNode
	S_NULL() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ON() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINAL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PROTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SAFE_OFFSET() antlr.TerminalNode
	SAFE_ORDINAL() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SSTRUCT() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TO() antlr.TerminalNode
	TREAT() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNION() antlr.TerminalNode
	UNNEST() antlr.TerminalNode
	USING() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITH() antlr.TerminalNode
	WITHIN() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = bigqueryParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = bigqueryParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserALL, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAND, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserANY, 0)
}

func (s *KeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserARRAY, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAS, 0)
}

func (s *KeywordContext) ASC() antlr.TerminalNode {
	return s.GetToken(bigqueryParserASC, 0)
}

func (s *KeywordContext) ASSERT_ROWS_MODIFIED() antlr.TerminalNode {
	return s.GetToken(bigqueryParserASSERT_ROWS_MODIFIED, 0)
}

func (s *KeywordContext) AT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserAT, 0)
}

func (s *KeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBETWEEN, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(bigqueryParserBY, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCASE, 0)
}

func (s *KeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCAST, 0)
}

func (s *KeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCOLLATE, 0)
}

func (s *KeywordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCONTAINS, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCREATE, 0)
}

func (s *KeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCROSS, 0)
}

func (s *KeywordContext) CUBE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCUBE, 0)
}

func (s *KeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserCURRENT, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDEFAULT, 0)
}

func (s *KeywordContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDEFINE, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDESC, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserDISTINCT, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserELSE, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEND, 0)
}

func (s *KeywordContext) ENUM() antlr.TerminalNode {
	return s.GetToken(bigqueryParserENUM, 0)
}

func (s *KeywordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserESCAPE, 0)
}

func (s *KeywordContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXCEPT, 0)
}

func (s *KeywordContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXCLUDE, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXISTS, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserEXTRACT, 0)
}

func (s *KeywordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFALSE, 0)
}

func (s *KeywordContext) FETCH() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFETCH, 0)
}

func (s *KeywordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFOLLOWING, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFOR, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFROM, 0)
}

func (s *KeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserFULL, 0)
}

func (s *KeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(bigqueryParserGROUP, 0)
}

func (s *KeywordContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserGROUPING, 0)
}

func (s *KeywordContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserGROUPS, 0)
}

func (s *KeywordContext) HASH() antlr.TerminalNode {
	return s.GetToken(bigqueryParserHASH, 0)
}

func (s *KeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserHAVING, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIF, 0)
}

func (s *KeywordContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIGNORE, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIN, 0)
}

func (s *KeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINNER, 0)
}

func (s *KeywordContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINTERSECT, 0)
}

func (s *KeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINTERVAL, 0)
}

func (s *KeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(bigqueryParserINTO, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserIS, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserJOIN, 0)
}

func (s *KeywordContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLATERAL, 0)
}

func (s *KeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLEFT, 0)
}

func (s *KeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLIKE, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLIMIT, 0)
}

func (s *KeywordContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(bigqueryParserLOOKUP, 0)
}

func (s *KeywordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserMERGE, 0)
}

func (s *KeywordContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNATURAL, 0)
}

func (s *KeywordContext) NEW() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNEW, 0)
}

func (s *KeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNO, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNOT, 0)
}

func (s *KeywordContext) S_NULL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserS_NULL, 0)
}

func (s *KeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserNULLS, 0)
}

func (s *KeywordContext) OF() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOF, 0)
}

func (s *KeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOFFSET, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(bigqueryParserON, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOR, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserORDER, 0)
}

func (s *KeywordContext) ORDINAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserORDINAL, 0)
}

func (s *KeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOUTER, 0)
}

func (s *KeywordContext) OVER() antlr.TerminalNode {
	return s.GetToken(bigqueryParserOVER, 0)
}

func (s *KeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(bigqueryParserPARTITION, 0)
}

func (s *KeywordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserPRECEDING, 0)
}

func (s *KeywordContext) PROTO() antlr.TerminalNode {
	return s.GetToken(bigqueryParserPROTO, 0)
}

func (s *KeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRANGE, 0)
}

func (s *KeywordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRECURSIVE, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserREPLACE, 0)
}

func (s *KeywordContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRESPECT, 0)
}

func (s *KeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserRIGHT, 0)
}

func (s *KeywordContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(bigqueryParserROLLUP, 0)
}

func (s *KeywordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(bigqueryParserROWS, 0)
}

func (s *KeywordContext) SAFE_OFFSET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSAFE_OFFSET, 0)
}

func (s *KeywordContext) SAFE_ORDINAL() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSAFE_ORDINAL, 0)
}

func (s *KeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSELECT, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSET, 0)
}

func (s *KeywordContext) SOME() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSOME, 0)
}

func (s *KeywordContext) SSTRUCT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSSTRUCT, 0)
}

func (s *KeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(bigqueryParserSYSTEM, 0)
}

func (s *KeywordContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTABLESAMPLE, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTHEN, 0)
}

func (s *KeywordContext) TIME() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTIME, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTO, 0)
}

func (s *KeywordContext) TREAT() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTREAT, 0)
}

func (s *KeywordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserTRUE, 0)
}

func (s *KeywordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNBOUNDED, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNION, 0)
}

func (s *KeywordContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUNNEST, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(bigqueryParserUSING, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWHEN, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWHERE, 0)
}

func (s *KeywordContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWINDOW, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWITH, 0)
}

func (s *KeywordContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(bigqueryParserWITHIN, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(bigqueryListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case bigqueryVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *bigqueryParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, bigqueryParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-31)) & ^0x3f) == 0 && ((int64(1)<<(_la-31))&-1) != 0) || ((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&274877906943) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *bigqueryParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *Query_exprContext = nil
		if localctx != nil {
			t = localctx.(*Query_exprContext)
		}
		return p.Query_expr_Sempred(t, predIndex)

	case 8:
		var t *From_itemContext = nil
		if localctx != nil {
			t = localctx.(*From_itemContext)
		}
		return p.From_item_Sempred(t, predIndex)

	case 16:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *bigqueryParser) Query_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bigqueryParser) From_item_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *bigqueryParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
